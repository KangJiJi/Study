# Stack

## 1. 구조

스택은 후입선출(Last In First Out: LIFO)의 자료구조로 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조로 되어 있다. 자료를 꺼낼때 가장 최근에 보관한 자료부터 나오게 된다.

## 2. 종류

스택은 자라는 방향(데이터가 쌓이는 방향)이 높은 주소로 자라는 것, 낮은 주소로 자라는 것이 있다. 높은 주소로 자라는 것은 Ascending Stack, 낮은 주소로 자라는 것은 Descending Stack 으로 분류한다. 또한 현재 Stack Pointer(SP)가 방금 push나 pop을 한 데이터를 포함하면 Full, 포함하지 않으면 Empty로 분류한다.

### Full Ascending Stack

SP는 유효한 데이터를 가르키고, 큰 주소 방향으로 늘어나는 스택

### Full Descending Stack

SP는 유효한 데이터를 가르키고, 작은 주소 방향으로 늘어나는 스택

### Empty Ascending Stack

SP는 유효한 데이터를 가르키지 않고, 큰 주소 방향으로 늘어나는 스택

### Empty Descending Stack

SP는 유효한 데이터를 가르키지 않고, 작은 주소 방향으로 늘어나는 스택

## 3. 용어(구현)

### top()

스택의 가장 위에있는 데이터를 넘겨준다. 만약 스택이 비어있다면 이 연산은 정의 불가 상태다.

### push()

스택의 가장 윗 데이터로 top이 가리키는 자리 위에 메모리를 생성하고, 데이터를 넣는다.

### pop()

스택의 가장 위에있는 데이터의 값을 넘겨주고 해당 데이터를 삭제한다. 만약 스택이 비어있다면 이 연산은 정의 불가 상태다.

### isEmpty()

스택이 비어있다면 참을 반환하고, 그렇지 않으면 거짓을 반환한다.

## 4. 용도

- 함수를 호출할 때 인수의 전달에 이용
- 함수가 함수를 호출하거나 재귀 호출때 이용

# Queue

## 1. 구조

큐는 선입선출(First In First Out: FIFO)의 자료구조다. 후입선출인 스택과 반대되는 자료구조다.

## 2. 종류

### 선형 큐

기본적인 큐의 형태이다. 빈 공간을 사용하기 위해서는 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있다.

### 원형 큐

선형 큐의 문제점을 보완한 큐다. 큐를 사용하다 보면 배열의 앞부분이 비는 점을 활용해서 front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내 원형으로 연결하는 방식이다.

### 우선순위 큐

원소들에게 우선순위를 매겨서 넣을 때의 순서와 상관없이 뺄 때에는 우선순위가 높은 원소부터 빼내는 것이다. 데이터를 넣을 때 우선순위에 따라 정렬하여 한쪽 방향에서만 데이터를 꺼내어 쓰도록 하면 된다.

### 링크드 큐(연결 리스트로 구현한 큐)

큐를 연결 리스트(Linked List)로 구현 한 것이다. 큐의 길이를 쉽게 늘릴 수 있어 오버플로우가 발생하지 않는 장점이 있다. 원형으로 만들지 않아도 삽입과 삭제가 제한되지 않아 편리하다.

### 덱(Deque: Double Ended Queue)

일반적인 큐와 다르게 양쪽에서 모두 삽입과 인출이 가능한 큐이다.

## 3. 용어(구현)

### put()

큐에 데이터를 넣는다. 만약 큐가 꽉 차서 더 이상 데이터를 넣을 수 없는 경우를 오버플로우(Overflow)라 한다.

### get()

큐에서 데이터를 꺼낸다. 만약 큐가 비어 있어서 더 이상 데이터를 꺼낼 수 없는 경우를 언더플로우(Underflow)라 한다.

### front()

head. 데이터를 get()할 수 있는 위치를 의미한다.

### rear()

tail. 데이터를 put()할 수 있는 위치를 의미한다.

### isEmpty()

큐가 비어있다면 참을 반환하고, 그렇지 않으면 거짓을 반환한다.

## 4. 용도

- 서로 다른 속도로 실행되는 서로 다른 프로세스 또는 쓰레드 간의 상호 작용을 조화시키는 버퍼 역할로 이용
- 큐잉이론에 따라 시스템의 특성을 시뮬레이션 하여 분석하는 데 이용

# List

## 1. 구조

순열(Sequence)이라고도 불리며, 순서를 가지고 일렬로 나열한 원소들의 모임으로 정의한다. 스택, 큐와 같은 선형의 자료구조다. 구현 방법에 따라 배열 리스트와 연결 리스트로 나눠 진다.

## 2. 종류

### 배열 리스트(Array List)

배열을 기반으로 구현한 리스트다.

### 연결 리스트(Linked List)

메모리 동적 할당을 기반으로 구현한 리스트다.

- 단일 연결 리스트(Singly Linked List)

  각 노드는 자료 공간과 한 개의 포인터 공간을 가지고 있고, 각 노드의 포인터는 다음 노드를 가리킨다.

- 원형 연결 리스트(Circular Linked List)

  일반적인 연결 리스트에 마지막 노드와 처음 노드를 연결시켜 원형으로 만든 구조이다.

- 이중 연결 리스트(Doubly Linked List)

  각 노드는 자료 공간과 두 개의 포인터 공간을 가지고 있고, 각각의 포인터는 앞의 노드와 뒤의 노드를 가리킨다.

- 이중 원형 연결 리스트(Doubly Circular Linked List)

  이중 연결 리스트에서 마지막 노드의 포인터가 처음 노드를 가리킨다.

## 3. 용어(구현)

### isEmpty()

리스트가 비어있다면 참을 반환하고, 그렇지 않으면 거짓을 반환한다.

### addHead()

리스트의 앞에 원소를 삽입한다.

### addTail()

리스트의 뒤에 원소를 삽입한다.

### peek()

리스트의 제일 첫 원소를 반환한다.

### printNode()

노드의 데이터를 출력한다.

### eraseNode()

노드를 삭제한다.

## 4. 용도

### 링크트 리스트

- 추가, 삽입, 삭제가 잦은곳에서 이용
- RT Computing(Real-Time Computing)에서 이용
- 랜덤하게 어떤 데이터에 접근할 필요가 없을때 이용

### 배열 리스트

- 특정 데이터에 접근 해야 할 때 이용
- 반복적으로 모든 데이터에 접근할때 빠른 속도가 필요한 경우에 이용

# Tree

## 1. 구조

트리는 부모 노드 밑에 자식 노드가 연결되고, 자식 노드 각각에 다시 자식 노드가 연결되는 재귀적 형태의 자료구조다. 만약 자식 노드의 자식 노드가 부모 노드로 연결되는 경우는 트리로 인정하지 않는다.

## 2. 종류

### 이진 트리(Binary Tree)

트리의 가장 간단한 형태로, 부모 노드 밑에 자식 노드가 최대 2개밖에 오지 않는 형태 이다. 부모 노드는 데이터와 오른쪽 노드, 왼쪽 노드를 각각 가리킬 두 개의 포인터를 가지고 있다. 왼쪽에 자식 노드, 오른쪽에 형제 노드를 배치(Left-Child, Right-Sibling)해 모든 트리를 이진 트리 형태로 재구성할 수 있다.

- 정 이진 트리(Full Binary Tree)

  모든 트리의 자식은 0개나 2개인 이진 트리

- 포화 이진 트리(Perfect Binary Tree)

  모든 리프 노드(자식이 없는 노드)의 높이가 같은 이진 트리

- 완전 이진 트리(Complete Binary Tree)

  트리의 원소를 왼쪽에서 오른쪽으로 하나도 빠짐없이 채워나간 형태의 이진 트리

### 이진 탐색 트리(Binary Search Tree, BST)

각 노드의 왼쪽 가지에는 노드의 값보다 작은 값들만 있고, 오른쪽 가지에는 큰 값들만 있도록 구성된 이진 트리다. 이러한 구조 덕분에 이진 탐색을 하기에 적합한 구성이 된다.

- AVL 트리

  자가 균형 이진 탐색 트리로 이상적인 상황에서나 최악으 상황에서 탐색, 삽입, 삭제 모두가 시간 복잡도가 O(log N)이다. 균형이 매우
  좋은 트리다.

- 레드블랙 트리(Red-Black Tree)

  자가 균형 이진 탐색 트리의 일종으로, 노드에 검정 또는 빨강인 색깔 속성이 붙은 트리다. 자식이 하나도 없는 노드 끝에는 널 리프 노
  드가 붙는다.

- 힙(Heap)

  힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전 이진 트리를 기본으로 한 자료구조다. 부모노드의 키값이 자식
  노드의 키값보다 항상 작은 힙을 '최소힙', 반대의 경우를 '최소힙'이라고 부른다.

### B-Tree

이진 트리를 확장한 트리로 자식 노드의 수가 2개 이상을 가질 수 있다. 노드에 접근 하는 시간 자체가 노드에서 연산하는 시간보다 훨씬 길 경우, B-tree를 쓴다.

- 2-3-4 tree

  B-tree of order 4(모든 노드가 가질 수 있는 자식 노들의 최대 수가 4개인 트리)의 일종이다.

- B+ tree

  루트 노드와 중간의 노드응 키를 이용하여 위치를 찾아가는 인덱스 역할만을 하며 데이터 자체는 모두 리프 노드에 저장하는 트리다.

### R 트리(R Tree)

R 트리는 B 트리와 비슷하며 다차원의 공간 데이터를 저장하는 색인이다.

### 포레스트(Forest)

하나 이상의 트리로 이루어진 집합을 포레스트 라고 한다.

## 3. 용어(구현)

### insert()

트리에 데이터를 넣는다.

### find()

트리에서 특정 데이터를 찾는다.

### remove()

트리에서 특정 데이터를 삭제한다.

## 4. 용도

- 컴퓨터의 디렉토리(Directory)구조에 이용
- 리스트를 정렬하기 위해 이진트리를 이용
- 명제식을 이진 트리로 표현하여 최종 결과를 내는데 이용
- 스레드를 이진 트리에 이용

# Graph

## 1. 구조

그래프는 정점(Vertex)과 정점을 연결하는 간선(Edge)으로 구성된 자료구조다.

## 2. 종류

### 유향 그래프(Directed Graph)

간선을 화살표로 나타내서 해당 방향으로만 이동할 수 있는 그래프

### 무향 그래프(Undirected Graph)

간선을 직선으로 나타내서 양방향으로 이동할 수 있는 그래프

### 가중 그래프(Weight Graph)

간선에 가중치가 할당된 그래프(Network)

### 다중 그래프(Multi Graph)

두 정점 사이에 두 개 이상의 간선이 있을수 있는 그래프

### DAG(Directed Acyclic Graph)

한 정점에서 출발해 자기 자신으로 돌아오는 경로가 존재하지 않는 방향 그래프

## 3. 구현 방법

### 인접 행렬(Adjacency Matrix)

배열을 이용한 그래프의 구현. 무향 그래프에서는 행렬이 대각선을 중심으로 대칭이다. 공간복잡도(필요한 기억장소의 크기)는 S(n) = n^2 다.

### 인접 리스트(Adjacency Lists)

연결 리스트를 이용한 그래프의 구현. n개의 연결리스트로 그래프를 표현한다.

## 4. 용어(구현)

### initGraph()

그래프를 초기화 시킨다.

### isEmpty()

그래프가 비어있다면 참을 반환하고, 그렇지 않으면 거짓을 반환한다.

### insertVertex()

정점을 삽입한다.

### insertEdge()

간선을 삽입한다.

### deleteVertex()

정점을 삭제한다.

### deleteEdge()

간선을 삭제한다.

## 5. 용도

- 최단경로를 구하는데 이용
- 컴퓨터 통신망에 이용
- 물리적인 모델링에 이용
- 추상적인 모델링에 이용
