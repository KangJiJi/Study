8장 동적 계획법
==============

## 01. 도입
&nbsp;동적 계획법은 프로그래밍 대회 문제에서 가장 자주 출현하는 디자인 패러다임 중 하나이다. 동적 계획법(Dynamic programming)이라는 말은 최적화 문제를 연구하는 수학 이론에서 왔으면, 우리가 전산학 전반에서 일반적으로 사용하는 동적(dynamic), 혹은 프로그래밍(programming)이란 단어와는 아무런 관련이 없다. 따라서 dynamic programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법이다.

### 중복되는 부분 문제
&nbsp;동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있다. 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산 하고 계산 결과를 재활용함으로써 속도의 향상을 불러온다. 그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다. 나눠진 각 문제들이 같은 부분 문제에 의존을 할 때, 단순하게 재귀 호출을 동해 각 문제를 해결하면 중복 계산이 많아진다. 계산의 중복 횟수는 분할이 깊이가 깊어질 수록 지수적으로 증가하게 된다. 이 현상을 조합 폭발(combination explosion)이라고 부른다. 이런 문제를 해결하기 위해 고안된 알고리즘 설계 기법이 동적 계획법이다. 가장 유명한 예 중 하나는 이항 계수(binomial coefficient)의 계산이다. bino(n, r)을 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것으로 한다.

```c++
bino(n, r) = bino(n - 1, r - 1) + bino(n - 1, r);
```

위와 같은 점화식이 성립한다.

```c++
int bino(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  return bino(n - 1, r - 1) + bino(n - 1, r);
}
```

위 코드는 재귀 호출을 이용해서 bino를 구현한 것이다. 이때 계산하는 과정에서 많은 중복이 일어나며, 숫자가 커질수록 함수 호출 횟수는 기하 급수적으로 늘어난다. 따라서 cache 배열을 만들어서 각 입력에 대한 반환 값을 저장한다. 한번 계산한 값을 저장해 뒀다 재활용 하는 기법을 메모이제이션(memoization)이라고 부른다.

```c++
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
}
```

이렇게 하면 함수 호출 횟수가 엄청나게 감소한다.

### 메모이제이션을 적용할 수 있는 경우
&nbsp;프로그래밍에서의 함수는 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수 많은 입력에 의해 작동하기 때문에 입력이 똑같다고 매번 출력이 같은 것은 아니다. 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들에만 적용할 수 있다.

### 메모이제이션 구현 패턴

```c++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```

위와 같은 함수를 다음과 같은 패턴으로 바꾼다.

```c++
// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아는 정수
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리한다.
  if(...) return ...;
  // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if(ret != -1) return ret;
  // 여기에서 답을 계산한다.
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache 배열을 초기화 시킨다
  memset(cache, -1, sizeof(cache));
}
```

이런 일관적인 패턴은 디버깅을 도와준다.

### 메모이제이션의 시간 복잡도 분석
&nbsp;간단하게 다음과 같은 식을 이용해서 시간 복잡도를 계산할 수 있다.

> (존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)

이 식은 항상 정확하지는 않지만 상한을 간단히 계산할 수 있는 방법이다.

### 예제: 외발 뛰기(문제 ID: JUMPGAME, 난이도: 하)
&nbsp;땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다. 균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다. 게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.

### 개인적 풀이
&nbsp;메모이제이션 기법을 사용하기 위해서 check[101][101]배열을 생성하고 각 좌표에서 출발해 본적이 있으면 1을 넣고 아니면 -1을 넣는다. 처음에 0, 0에서 시작하고 재귀적으로 갈수 있는 좌표 모두를 가본다. 이렇게 n, n에 도달 했는지를 검사한다.

```c++
int n;
int board[101][101];
int check[101][101];
checkBoard(int x, int y) {
  // 기저 사례 끝부분에 도착하면 2를 반환하고 접근할 수 없는 인덱스에 접근했을 때 -1을 반환
  if(x == n && y == n) return 2;
  if(x > n || y > n) return -1;

  // 특정 좌표에서 출발해 본적이 있는지 검사
  int ret = check[x][y];
  if(ret == 1) return ret;

  int& move = board[101][101];
  ret = checkBoard(x + move, y) || checkBoard(x, y + move);

  return ret;
}
```

이런 방향성을 가지고 풀게 되면 될 것 같다.

### 재귀 호출에서 시작하기
&nbsp;동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 모든 경로를 하나씩 만들어 봄녀서 마지막 칸에 도달할 수 있는지를 검사한다.

```c++
int n, board[100][100];
bool jump(int y, int x) {
  // 기저 사례: 게임판 밖을 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n - 1 && x == n - 1) return true;
  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

### 메모이제이션 적용하기
&nbsp;완전 탐색을 사용할 때 흔히 가장 문제가 되는 것은 원하는 전체 답의 개수는 무지막지하게 많은 경우다. 다음은 메모이제이션을 적용해서 중복을 없애는 코드다.

```c++
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
  // 기저 사례
  if(y >= n || x >= n) return 0;
  if(y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if(ret != -1) return ret;
  int jumpSize = board[y][x];
  return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```

### 내가 짠 코드와 비교해 보기
&nbsp;아이디어는 똑같았지만 아직 언어에 대한 이해와 문법 능력이 부족해 오류가 나는 코드를 만들었다. 포인터와 언어에 대한 이해가 조금더 필요하다.


### 다른 해법
&nbsp;이 문제는 사실 크래프로 모델링해보면 아주 간단한 도달 가능성 문제가 된다.

### 동적 계획법 레시피
&nbsp;1. 주어진 문제를 완전 탐색을 이용해 해결한다. 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

### 다른 구현 방법에 관하여
&nbsp;재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현할 수 있다. 이런 방법을 반복적 동적 계획법이라고 부른다.

## 02. 문제: 와일드카드(문제 ID: WILDCARD, 난이도: 중)
&nbsp;와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다. 와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다. 예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다. 와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

### 시간 및 메모리 제한
&nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

### 출력
&nbsp;각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

### 개인적 풀이
&nbsp;이 문제에 대해서는 풀이법이 잘 떠오르지 않는다.

## 03. 풀이: 와일드카드

### *가 문제로다
&nbsp;이 문제를 어렵게 만드는 것은 *가 몇 글자에 대응되어야 하는지를 미리 알 수 없다는 점이다. 주어진 패턴이 m개의 *을 포함한다고 한다. 이 패턴을 *가 나타날 때마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌 수 있다. 예를 들어 t*l?*o*r?ng*s는 t*, l?*, o*, r?ng*, s로 나눌 수 있다. 이렇게 쪼갠 문자열이 대응되는지 여부를 재귀 호출로 파악할 수 있다. 물론 실제로 패턴을 쪼개지 않고도 이를 구현할 수 있다.

```c++
// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {
  // w[pos]와 s[pos]를 맞춰나간다.
  int pos = 0;
  while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos]))
    ++pos;
  // 더이상 대을할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨.
  if(pos == w.size())
    return pos == s.size();
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(w[pos] == '*')
    for(int skip = 0; pos + skip <= s.size(); ++skip)
      if(match(w.substr(pos + 1), s.substr(pos + skip)))
        return true;
  // 이 외의 경우에는 모두 대응되지 않는다.
  return false;
}
```

### 중복되는 부분 문제
&nbsp;위와 같은 방법은 *가 많을 수록 이 경우의 수는 늘어나서 오랜 시간이 걸린다. 예를 들어 123*abc*def*ghi이 패턴에는 '*'가 세 개 있는데 이때 def*ghi 부분이 123*...과 abc*...를 해결할 때 중복된다. 입력으로 주어질 수 있는 w와 s는 각각 최대 101개밖에 없다. 다음과 같이 메모이제이션을 사용해 중복 계산을 줄일 수 있다.

```c++
// -1은 아직 답이 계산되지 않았음을 의미한다.
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열
string W, S;
// 파일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s) {
  // 메모이제이션
  int& ret = cache[w][s];
  if(ret != -1) return ret;
  // W[w]와 S[s]를 맞춰나간다.
  while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
    ++w;
    ++s;
  }
  // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참
  if(w == W.size()) return ret = (s == S.size());
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(W[w] == '*')
    for(int skip = 0; skip + s <= S.size(); ++skip)
      if(matchMemoized(w + 1, s + skip))
        return ret = 1;
  // 3. 이 외의 경우에는 모두 대응되지 않는다.
  return ret = 0;
}
```

### 다른 분해 방법
&nbsp;다른 분해 방식을 사용하면 이 문제를 O(n^2)시간에 풀 수 있다.

## 04. 전통적 최적화 문제들
&nbsp;동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제에 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기보다 좀더 효율적으로 동적 계획법을 구현할 수 있다.

### 예제: 삼각형 위의 최대 경로(문제 ID: TRIANGLEPATH, 난이도: 하)
6<br>
1 2<br>
3 7 4<br>
&nbsp;위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

### 개인적 풀이
&nbsp;일단 완전 탐색을 통해서 아래로 갈 것인지 아니면 오른쪽 아래로 갈 것인지 찾아내면 될 것 같다.

```c++
int n;
int board[100][100];
int boardMaxSum[100][100];

int findMaxSum(int y, int x) {
  // 기저 사례: 삼각형이 아닌 부분을 참조하려 했을 때
  if(y >= n || x > y + 1 || y < 0 || x < 0) return 0;
  
  // x - 1값이 0 미만 일때
  if(x - 1 < 0) {
    // y - 1값이 0미만 일 때
    if(y - 1 < 0) {
      boardMaxSum[y][x] = board[y][x];
    } else {
      boardMaxSum[y][x] = board[y][x] + board[y - 1][x];
    }
  } else {
    // 특정 [y][x]에서의 최대 값은 [y - 1][x - 1]와 [y - 1][x]중 큰 값에 [y][x]값을 더 한 것이다.
    if(boardMaxSum[y - 1][x - 1] > boardMaxSum[y - 1][x]) {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x - 1];
    } else {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x];
    }
  }

  // 아래로 이동
  findMaxSum(y + 1, x);
  // 오른쪽 아래로 이동
  findMaxSum(y + 1, x + 1);
};
```

> 이런식으로 재귀 호출을 하게 되면 계산 되지 않은 값을 참조하는 경우가 생기기 때문에 안된다.

### 완전 탐색으로 시작하기
&nbsp;재귀 호출을 하는데 현재 위치와 지금가지 만난 숫자들의 함을 전달한다. pathSum(y, x, sum)이 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum일 때, 이 결로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환한다.

### 무식하게 메모이제이션 적용하기
&nbsp;n개의 가로줄이 있으면 가능한 경로의 수는 2^(n - 1)이다. 이때 n이 100정도만 돼도 계산할 수 없다. 다음과 같은 코드를 보자.

```c++
// MAX_NUMBER: 한 칸에 들어갈 숫자의 최대치
int n, triangle[100][100];
int cache[100][100][MAX_NUMBER * 100 + 1];
// y, x 위치까지 내려오기 전에 만난 숫자들의 합이 sum일 때 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로를 반환한다.
int path1(int y, int x, int sum) {
  // 기저 사례: 맨 아래 줄까지 도달했을 경우
  if(y == n - 1) return sum + triangle[y][x];
  // 메모이제이션
  int& ret = cache[y][x][sum];
  if(ret != -1) return ret;
  sum += triangle[y][x];
  return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
```

이 코드는 완전 탐색과 다를 바가 없다.

### 입력 걸러내기
&nbsp;재귀 함수의 입력을 다음과 같이 두 부류로 나눠본다.
* y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 이 두 입력이 정해지면 앞으로 우리가 만들 수 있는 경로들이 정해진다. 따라서 이들은 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들이다.
* 반면 sum은 지금가지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. sum은 지금가지 풀었던 조각들에 대한 정보를 주는 입력이다.

path2(y, x)는 y, x에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.

```c++
int n, triangle[100][100];
int cache2[100][100];
// (y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path2(int y, int x) {
  // 기저 사례
  if(y == n - 1) return triangle[y][x];
  //메모이제이션
  int& ret = cache2[y][x];
  if(ret != -1) return ret;
  return ret = max(path2(y + 1, x), path2(y + 1, x + 1)) + triangle[y][x];
}
```

0, 0부터 내려가는 것이 아닌 마지막 줄부터 올라온다.

### 내가 짠 코드와 비교해보기
&nbsp;해야하는 방향성은 알겠지만 코드로 구현하는 것이 매우 힘들다. 지속적으로 틀린다. 책에 써져 있는 코드는 깔끔하게 잘 써져 있어서 좋은 듯 하다.

### 이론적 배경: 최적 부분 구조
&nbsp;최적화가 가능했던 이유는 sum이라는 정보가 (y, x)에서 맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다는 사실을 파악한 덕분이다. 지금 까지 어던 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관 없다. 이것은 효율적인 동적 계획법 알고리즘을 적용하기 위해 아주 중요한 조건이다. 최적 부분 구조(Optimal substructure)이라고 불린다.

### 예제: 최대 증가 부분 수열(문제 ID: LIS, 난이도: 하)
&nbsp;어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다. 어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라. 어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

### 개인적 풀이
&nbsp;이 문제도 위의 문제와 유사하게 풀면 될 것 같다. 메모이제이션을 이용하며 현재 값보다 큰 값을 찾고 그 위치에서 다시 큰 값을 찾으며 최대 길이를 찾는다.

```c++
int length, sequence[500];
int cache[500];

int maxLength(int index) {
  // 기저 사례
  if(index >= length) return 0;

  //메모이제이션
  int& ret = cache[index + 1];
  if(ret != -1) return ret;

  for(int i = index + 1; i < length; i++) {
    if(sequence[index] < sequence[i]) {
      if(ret < maxLength(i) + 1){
        ret = maxLength(i) + 1;
      }
    }
  }

  return ret;
}
```

### 완전 탐색에서 시작하기
&nbsp;최대 증가 수열을 찾는 문제를 숫자 하나씩으로 조각낸 뒤, 한 조각에서 숫자 하나씩을 선택하는 완전 탐색 알고리즘을 만든다. lis(A)는 수열 A를 입력 받아 LIS의 길이를 반환한다.

```c++
int lis(const vector<int>& A) {
  // 기저 사례: A가 텅 비어 있을 때
  if(A.empty()) return 0;
  int ret = 0;
  for(int i = 0; i < A.size(); ++i) {
    vector<int> B;
    for(int j = i + 1; j < A.size(); ++j)
      if(A[i] < A[j])
        B.push_back(A[j]);
    ret = max(ret, 1 + lis(B));
  }
  return ret;
}
```

### 입력 손보기
&nbsp;A는 항상 다음 두 가지 중 하나가 된다.

* 원래 주어진 수열 S
* 원래 주어진 수열의 원소 S[i]에 대해, S[i + 1...] 부분 수열에서 S[i]보다 큰 수들만을 포함하는 부분 수열

S[start]는 S[start]보다 뒤에 있고 큰 수들 중 하나를 다음 숫자로 결정한 뒤, 여기서 시작하는 부분 증가 수열의 최대치를 구한다.

```c++
int n;
int cache[100], S[100];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis2(int start) {
  int& ret = cache[start];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  for(int next = start + 1; next < n; ++next) {
    if(S[start] < S[next])
      ret = max(ret, lis2(next) + 1);
  }
  return ret;
}
```

### 시작 위치 고정하기

```c++
int n;
int cache[101], S[101];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis3(int start) {
  int& ret = cache[start + 1];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  for(int next = start + 1; next < n; ++next) {
    if(S[start] < S[next])
      ret = max(ret, lis3(next) + 1);
  }
  return ret;
}
```

### 내가 짠 코드와 비교해보기
&nbsp;어느 정도의 방향성이나 생각하는 방향은 다 맞은 것 같다. 하지만 크기 비교를 위해서 if문 대신 max를 사용하는 것이 앞으로도 더 좋을 것 같다. 또한 위에서 나온 템플릿을 잘 외워야 할 것 같다.

### 더 빠른 해법
&nbsp;O(nlgn)에 찾을 수 있다.

### 최적화 문제 동적 계획법 레시피
* 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다.
* 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환한도록 부분 문제 정의를 바꾼다.
* 가능한 한 중복되는 부분 문제를 많이 만들어야 한다. 이러면 메모이제이션을 최대한도로 활용할 수 있다.
* 입력이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 한다.
* 메모이제이션을 적용한다.

## 05. 문제: 합친 LIS(문제 ID: JLIS, 난이도: 하)
&nbsp;어떤 수열에서 0개 이상의 숫자를 지운 결과를 원 수열의 부분 수열이라고 부릅니다. 예를 들어 '4 7 6'은 '4 3 7 6 9'의 부분 수열입니다. 중복된 숫자가 없고 오름 차순으로 정렬되어 있는 부분 수열들을 가리켜 증가 부분 수열이라고 부르지요. 예를 들어 '3 6 9'는 앞의 수열의 증가 부분 수열입니다. 두 개의 정수 수열 A 와 B 에서 각각 증가 부분 수열을 얻은 뒤 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 부르기로 합시다. 이 중 가장 긴 수열을 합친 LIS(JLIS, Joined Longest Increasing Subsequence)이라고 부릅시다. 예를 들어 '1 3 4 7 9' 은 '1 9 4' 와 '3 4 7' 의 JLIS입니다. '1 9' 와 '3 4 7' 을 합쳐 '1 3 4 7 9'를 얻을 수 있기 때문이지요. A 와 B 가 주어질 때, JLIS의 길이를 계산하는 프로그램을 작성하세요.

### 시간 및 메모리 제한
&nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 c ( 1 <= c <= 50 ) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 A 와 B 의 길이 n 과 m 이 주어집니다 (1 <= n,m <= 100). 다음 줄에는 n 개의 정수로 A 의 원소들이, 그 다음 줄에는 m 개의 정수로 B 의 원소들이 주어집니다. 모든 원소들은 32비트 부호 있는 정수에 저장할 수 있습니다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에, JLIS 의 길이를 출력합니다.

### 개인적 풀이
&nbsp;이 문제에서 조심해야 할 부분은 두개의 부분 수열에서 겹치는 숫자가 있는 경우다. 만약 a, b라는 최대 길이 부분 수열이 있는데 이 두개가 거의 혹은 완전 똑같다면, 합친 부분 수열은 최대의 길이가 아닌 수열이 될 것 이다. 첫번째로 가장 긴 합친 부분 수열을 만들 수 있는 알고리즘을 생각해 본다. 이때 최대 부분 수열을 구하는 함수와 다른 점은 배열이 두개라 모든 값들을 한번씩 맨 앞으로 배치해 봤을 때 메모이제이션 하는 것을 주의 하면 된다.

```c++
// 메모이제이션
int cache[2][101], s[2][101];
int length1, length2;

int jlis(int choiceString, int start) {
  // 기저 사례
  if(string > 100) return 0;
  int& ret = cache[choiceString][start + 1];
  if(ret != -1) return ret;
  
  int index1, index2 = 0;

  if(choiceString == 0) {
    index1 = start;
  } else {
    index2 = start;
  }

  for(int i = index1; i < length1; i++) {
    for(int j = index2; j < length2; j++) {
      // 두번째 문자열에서 부분 수열 찾기
      if(s[choiceString][i] < s[1][j]) {
        ret = max(ret, jlis(1, j + 1) + 1);
      }
    }
    // 첫번째 문자열에서 부분 수열 찾기
    if(s[choiceString][i] < s[0][j]) {
      ret = max(ret, jlis(0, i + 1) + 1);
    }
  }
  
  return ret;
}
```

## 06. 풀이: 합친LIS

### 탐욕법으로는 안 된다
&nbsp;이 문제는 LIS 찾기 문제의 확장판이다. 두 수열의 LIS를 찾아서 합치는 것 만으로는 해결할 수 없다.

### 비슷한 문제를 풀어 본 적이 있군요
&nbsp;jlis(indexA, indexB) == A[indexA]와 B[indexB]에서 시작하는 합친 증가 부분 수열의 최대 길이라 한다.

```c++
// 입력이 32비트 부호 있는 정수의 모든 값을 가질 수 있으므로 인위적인 최소치는 64비트여야 한다.
const long long NEGINF = numeric_limits<long long>::min();
int n, m, A[100], B[100];
int cache[101][101];
// min(A[indexA], B[indexB]), max(A[indexA], B[indexB])로 시작하는 합친 증가 부분 수열의 최대 길이를 반환한다.
// 단 indexA == indexB == -1 혹은 A[indexA] != B[indexB]라고 가정한다.
int jlis(int indexA, int indexB) {
  // 메모이제이션
  int& ret = cache[indexA + 1][indexB + 1];
  if(ret != -1) return ret;
  // A[indexA], B[indexB]가 이미 존재하므로 2개는 항상 있다.
  ret = 2;
  long long a = (indexA == -1 ? NEGINF : A[indexA]);
  long long b = (indexB == -1 ? NEGINF : B[indexB]);
  long long maxElement = max(a, b);
  // 다음 원소를 찾는다
  for(int nextA = indexA + 1; nextA < n; ++nextA)
    if(maxElement < A[nextA])
      ret = max(ret, jlis(nextA, nextB) + 1);
  for(int nextB = indexB + 1; nextB < m; ++nextB)
    if(maxElement < B[nextB])
      ret = max(ret, jlis(indexA, nextB) + 1);
  return ret;
}
```

### 내가 짠 코드와 비교해 보기
&nbsp;생각은 비슷했지만 내가 짠 코드는 동작하지 않는다. 왜냐하면 첫번째 값만 고정시키고 나머지 원소들을 비교하려고 했기 때문이다. 이렇게 되면 크기 비교도 잘 작동하지 못한다.

## 07. 문제: 원주율 외우기(문제 ID: PI, 난이도: 하)
&nbsp;가끔 TV 에 보면 원주율을 몇만 자리까지 줄줄 외우는 신동들이 등장하곤 합니다. 이들이 이 수를 외우기 위해 사용하는 방법 중 하나로, 숫자를 몇 자리 이상 끊어 외우는 것이 있습니다. 이들은 숫자를 세 자리에서 다섯 자리까지로 끊어서 외우는데, 가능하면 55555 나 123 같이 외우기 쉬운 조각들이 많이 등장하는 방법을 택하곤 합니다. 이 때, 각 조각들의 난이도는 다음과 같이 정해집니다.

* 모든 숫자가 같을 때 (예: 333, 5555) 난이도: 1
* 숫자가 1씩 단조 증가하거나 단조 감소할 때 (예: 23456, 3210) 난이도: 2
* 두 개의 숫자가 번갈아 가며 출현할 때 (예: 323, 54545) 난이도: 4
* 숫자가 등차 수열을 이룰 때 (예: 147, 8642) 난이도: 5
* 그 외의 경우 난이도: 10

원주율의 일부가 입력으로 주어질 때, 난이도의 합을 최소화하도록 숫자들을 3자리에서 5자리까지 끊어 읽고 싶습니다. 최소의 난이도를 계산하는 프로그램을 작성하세요.

### 시간 및 메모리 제한
&nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어집니다. 각 테스트 케이스는 8글자 이상 10000글자 이하의 숫자로 주어집니다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에 최소의 난이도를 출력합니다.

### 개인적 풀이
&nbsp;완전 탐색을 하기위해서 문자열 첫부분을 3자리, 4자리, 5자리, 끊어서 각각의 남은 문자열에 대해서 다시 3자리, 4자리, 5자리 씩 끊어서 확인을 해보면 될 것 같다. 다만 문자열 길이가 최대 10000까지 된다. 그래서 메모이제이션을 이용해 각각의 남은 배열에 대한 최소의 난이도를 계속 저장한다.

```c++
int cache[10000];
int pi[10000];

int checkLevel(int index, int checkLength) {
  int check1 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] == pi[index + i + 1]) check1++;
  }
  if(check1 == checkLength - 1) return 1;

  int check2 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] - pi[index + i + 1] == 1) check2++;
    if(pi[index + i] - pi[index + i + 1] == -1) check2--;
  }
  if(check2 == (-1 * checkLength) + 1 || check2 == checkLength - 1) return 2;

  int check3 = 0;
  if(checkLength == 3) {
    if(pi[index] == pi[index + 2]) check3++;
  } else if(checkLength == 4) {
    if(pi[index] == pi[index + 2] && pi[index + 1] == pi[index + 3]) check3++;
  } else {
    if(pi[index] == pi[index + 2] && pi[index] == pi[index + 3] && pi[index + 1] == pi[index + 3]) check3++;
  }
  if(check3 == 1) return 4;

  int check4 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] - pi[index + i + 1] == pi[index] - pi[index + 1]) check4++;
  }
  if(check4 == checkLength - 1) return 5;

  return 10;
}

int minPiLevel(int index, int checkLength) {
  if(index > 10000) return 10;
  
  int& ret = cache[index];
  if(ret != -1) return ret;
  
  int level = checkLevel(index, checkLength);
  ret += level;

  for(int i = 0; i < 3; i++) {
    ret = min(ret, minPiLevel(index + checkLenth, 3 + i));
  }

  return ret;
}
```

## 08. 풀이: 원주율 외우기

### 일만 자리나 외우라고?
&nbsp;입력의 크기를 보면 어떤 방식이든지 완전 탐색으로 이 문제를 해결하기란 불가능하다는 것을 본능 적으로 알 수 있다. 길이가 7인 수열은 두 가지 방법으로 쪼갤 수 있는데 이런 수열이 n개 있으면 쪼갤 수 있는 방법의 수는 2^n개가 되는데, 길이가 10000인 수열에는 1,428개가 들어갈 수 있다.

### 메모이제이션의 적용
&nbsp;전체 문제의 최적해는 다음 세 경우 중 가장 작은 값이 된다.

* 길이 3인 조각의 난이도 + 3글자 빼고 나머지 수열에 대한 최적해
* 길이 4인 조각의 난이도 + 4글자 빼고 나머지 수열에 대한 최적해
* 길이 5인 조각의 난이도 + 5글자 빼고 나머지 수열에 대한 최적해

나머지 수열의 최적해를 구할 때 앞의 부분을 어떤 식으로 쪼갰는지는 중요하지 않다.

### 구현

```c++
string N;
// N[a..b]구간의 난이도를 반환한다.
int classify(int a, int b);
int cache[10002];
// 수열 N[begin..]를 외우는 방법 중 난이도의 최솟합을 출력한다.
int memorize(int begin) {
  // 기저 사례: 수열의 끝에 도달했을 경우
  if(begin == N.size()) return 0;
  // 메모이제이션
  int& ret = cache[begin];
  if(ret != -1) return ret;
  ret = INF;
  for(int L = 3; L <= 5; ++L)
    if(begin + L <= N.size())
      ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));
  return ret;
}
```

### 내가 짠 코드와 비교해 보기
&nbsp;index까지의 최솟값을 구해서 메모이제이션을 이용하는 방법은 똑같다. 다만 내가 짠 코드는 3글자에서 5글자를 변수 length 인자값으로 넘겨서 사용했고, ret을 -1로 초기화는 했지만 최솟값을 찾는 문제였기에 ret에 최대 값을 넣었어야 했다.

## 09. 문제: Quantization(문제 ID: QUANTIZE, 난이도: 중)
&nbsp;Quantization (양자화) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 갖는 값들로 근사해 표현함으로써 자료를 손실 압축하는 과정을 말한다. 예를 들어 16비트 JPG 파일을 4컬러 GIF 파일로 변환하는 것은 RGB 색 공간의 색들을 4컬러 중의 하나로 양자화하는 것이고, 키가 161, 164, 170, 178 인 학생 넷을 '160대 둘, 170대 둘' 이라고 축약해 표현하는 것 또한 양자화라고 할 수 있다. 1000 이하의 자연수들로 구성된 수열을 최대 S종류 의 값만을 사용하도록 양자화하고 싶다. 이 때 양자화된 숫자는 원래 수열에 없는 숫자일 수도 있다. 양자화를 하는 방법은 여러 가지가 있다. 수열 1 2 3 4 5 6 7 8 9 10 을 2개의 숫자만을 써서 표현하려면, 3 3 3 3 3 7 7 7 7 7 과 같이 할 수도 있고, 1 1 1 1 1 10 10 10 10 10 으로 할 수도 있다. 우리는 이 중, 각 숫자별 오차 제곱의 합을 최소화하는 양자화 결과를 알고 싶다. 예를 들어, 수열 1 2 3 4 5 를 1 1 3 3 3 으로 양자화하면 오차 제곱의 합은 0+1+0+1+4=6 이 되고, 2 2 2 4 4 로 양자화하면 오차 제곱의 합은 1+0+1+0+1=3 이 된다. 수열과 S 가 주어질 때, 가능한 오차 제곱의 합의 최소값을 구하는 프로그램을 작성하시오.

### 시간 및 메모리 제한
&nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열의 길이 N (1 <= N <= 100), 사용할 숫자의 수 S (1 <= S <= 10) 이 주어진다. 그 다음 줄에 N개의 정수로 수열의 숫자들이 주어진다. 수열의 모든 수는 1000 이하의 자연수이다.

### 출력
&nbsp;각 테스트 케이스마다, 주어진 수열을 최대 S 개의 수로 양자화할 때 오차 제곱의 합의 최소값을 출력한다.

### 개인적 풀이
&nbsp;일단 완전 탐색법으로는 1 ~ 1000중 S개의 자연수를 골라서 배열 N을 S부분으로 나눠서 오차 제곱의 합을 구하고 최솟값을 찾아낸다.

## 10. 풀이: Quantization

### 하던 대로는 안 된다
&nbsp;단순하게 생각해 보면 양자화된 결과 수열을 답으로 생각하고, 맨 앞의 숫자에서부터 하나씩 채워 나가는 접근 방법을 택하게 된다.
quantize(A, U) = U가 지금까지 한 번 이상 사용한 숫자들의 집합일 때 A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합.
하지만 이런 완전 탐색 코드는 너무 오래 걸려서 답을 구할 수 없다.

### 답의 형태 제한하기
&nbsp;답의 구조를 예측하고 그것을 강제한다. 주어진 수열을 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다. 따라서 이 문제는 이제 주어진 수열을 s개의 묶음으로 나누는 문제가 된다. 매 재귀 호출 때마다, 첫 묶음의 크기가 얼마일지를 결정하면 된다. from번째 이후 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다고 한다. 첫 번째 묶음의 크기가 size일 떄의 최소 오류는 minError(from, from + size + 1) + quantize(from + size, parts - 1)이 된다.

### 한 개의 구간에 대한 답 찾기
&nbsp;minError(a, b)에서 해야 하는 일은 크게 두 가지이다.
* 주어진 구간을 어떤 수로 표현해야 할지 결정하기
* 결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기
모든 값의 평균을 사용하면 오차를 최소화할수 있다.

### 구현

```c++
const int INF = 987654321;
// A[]: 양자화해야 할 수열, 정렬한 상태
// pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]^2..A[i]^2의 합
// pSqSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2..A[i]^2의 합
int n;
int A[101], pSum[101], pSqSum[101];
// A를 정렬하고 각 부분합을 계산한다.
void precalc() {
  sort(A, A + n);
  pSum[0] = A[0];
  pSqSum[0] = A[0] * A[0];
  for(int i = 1; i < n; ++i) {
    pSum[i] = pSum[i - 1] + A[i];
    pSqSum[i] = pSqSum[i - 1] + A[i] * A[i];
  }
}
// A[lo]..A[hi]구간을 하나의 숫자로 표현할 때 최소 오차 합을 계산한다.
int minError(int lo, int hi) {
  // 부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.
  int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);
  int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);
  // 평균을 반올림한 값으로 이 수들을 표현한다.
  int m = int(0.5 + (double)sum / (hi - lo + 1));
  // sum(A[i] - m) ^ 2를 전개한 결과를 부분 합으로 표현
  int ret = sqSum - 1 * m * sum + m * m * (hi - lo + 1);
  return ret;
}
int cache[101][11];
int quantize(int from, int parts) {
  // 기저 사례: 모든 숫자를 다 양자화 했을 때
  if(from == n) return 0;
  // 기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값을 반환한다.
  if(parts == 0) return INF;
  int& ret = cache[from][parts];
  if(ret != -1) return ret;
  ret = INF;
  // 조각의 길이를 변환시켜 가며 최소치를 찾는다.
  for(int partSize = 1; from + partSize <= n; ++partSize)
    ret = min(ret, minError(from, from + partSize - 1) + quantize(from + partSize, parts - 1));
  return ret;
}
```

## 11. 경우의 수와 확률
&nbsp;동적 계획접은 애초에 최적화 문제를 풀기 위해 고안되었지만, 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용된다.

### 오버플로에 유의하기
&nbsp;많은 경우 답이 32비트 정수형의 한계를 초과하기 십상이다.

### 예제: 타일링 방법의 수 세기(문제 ID: TILING2, 난이도: 하)
&nbsp;2xn 크기의 사각형을 2x1 크기의 사각형으로 빈틈없이 채우는 경우의 수를 구하는 프로그램을 작성하세요. n의 최대 값이 100이라고 할 때 타일을 채우는 방법의 수를 어떻게 셀 수 있을까?

### 개인적 풀이
&nbsp;타일을 놓는 방법은 세워서 하나를 두거나 눞혀서 2개를 두거나 두가지 경우의 수다. 따라서 완전 탐색을 이용해 재귀적으로 인자값으로 남은 칸을 수를 넘기고 세워서 두는 경우랑 눞혀서 2개를 두는 경우를 실행해 보면 될 것 같다. 또한 메모이 제이션을 통해서 이미 계산 해본 경우의 수는 저장해 재귀 호출을 하지 않고 사용한다.

```c++
int cache[101];

int counting(int remainSection) {
  if(remainSection == 0) return 1;
  int& ret = cache[remainSection];
  if(ret != -1) return ret;

  ret += counting(remainSection - 1);
  if(remainSection > 1) ret += counting(remainSection - 2);

  return ret;
}
```

### 풀이
&nbsp;완전 탐색을 이용해 모든 답을 만들면서 개수를 세어보는 함수를 작성 한 뒤, 메모이제이션을 이용해 동적 계획법 알고리즘으로 바꿔 본다. tiling(n)는 2 * n 크기의 사각형을 타일로 덮는 방법을 반환한다. 이때 다음과 같은 점화식이 성립한다. tiling(n) = tiling(n - 1) + tiling(n - 2). n이 100이면 경우의 수는 64비트 정수형의 표현 범위도 훌쩍 넘어가는 큰 값이 된다.

```c++
const int MOD = 1000000007;
int cache[101];
// 2 * width 크기의 사각형을 채우는 방법의 수를 MOD로 나눈 나머지를 반환한다.
int tiling(int width) {
  // 기저 사례: width가 1 이하일 때
  if(width <= 1) return 1;
  // 메모이제이션
  int& ret = cache[width];
  if(ret != -1) return ret;
  return ret = (tiling(width - 2) + tiling(width - 1)) % MOD;
}
```

이 알고리즘의 부분 문제의 수는 O(n)이고, 각각의 값을 계산하는 데 O(1)의 시간이 들기 때문에 전체 시간 복잡도는 O(n)이 된다.

### 예제: 삼각형 위의 최대 결로 개수 세기(문제 ID: TRIPATHCNT, 난이도: 중)
&nbsp;맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 숫자의 합이 가장 큰 경로는 하나가 아니라 여러 개일 수 있습니다. 예를 들어 위 삼각형에서는 {9, 7, 2, 6}과 {9, 7, 3, 5}의 합이 모두 최대인 24이고, {9, 7, 3, 5}는 두 번 등장하거든요. 삼각형이 주어질 때 최대 경로의 수를 세는 프로그램을 작성하세요.
9
5 7
1 3 2
3 5 5 6

### 개인적 풀이
&nbsp;최대 합을 구하는 코드는 이전에 구현한 적이 있다. 이 문제를 풀어낼 방법이 떠오르지 않는다.

### 풀이
&nbsp;이 문제를 해결하기 위해서는 두 개의 다른 동적 계획법 문제를 해결해야 한다. 먼저 바탕이 되는 최적화 문제를 푼 뒤, 각 부분 문제마다 최적해의 개수를 계산하는 동적 계획법 알고리즘을 만든다. cahce에 저장 되어 있는 삼각형을 이용해서 문제를 푼다. 더 큰 값을 찾고, 만약 갈수 있는 경로가 같은 값이 있으면 재귀적으로 탐색한다.

```c++
int n, triangle[100][100];
int cache2[100][100];
int countCache[100][100];

int path2(int y, int x) {
  // 기저 사례
  if(y == n - 1) return triangle[y][x];
  //메모이제이션
  int& ret = cache2[y][x];
  if(ret != -1) return ret;
  return ret = max(path2(y + 1, x), path2(y + 1, x + 1)) + triangle[y][x];
}

// (y, x)에서 시작해서 맨 아래줄까지 내려가는 경로 중 최대 경로의 개수를 반환한다.
int count(int y, int x) {
  // 기저 사례: 맨 아래줄에 도달한 경우
  if(y == n - 1) return 1;
  // 메모이제이션
  int& ret = countCache[y][x];
  if(ret != -1) return ret;
  ret = 0;
  if(path2(y + 1, x + 1) >= path2(y + 1, x)) ret += count(y + 1, x + 1);
  if(path2(y + 1, x + 1) <= path2(y + 1, x)) ret += count(y + 1, x);
  return ret;
}
```

### 예제: 우물을 기어오르는 달팽이
&nbsp;깊이가 n 미터인 우물의 맨 밑바닥에 달팽이가 있습니다. 이 달팽이는 우물의 맨 위까지 기어올라가고 싶어하는데, 달팽이의 움직임은 그 날의 날씨에 좌우됩니다. 만약 비가 내리면 달팽이는 하루에 1미터를 기어올라갈 수 있고, 날이 맑으면 2미터를 올라갈 수 있다. 여름 장마가 찾아와, 앞으로 m 일간 각 날짜에 비가 올 확률이 정확히 50%일 전망입니다. m 일 안에 달팽이가 우물 끝까지 올라갈 확률을 계산하는 프로그램을 작성하세요.

### 개인적 풀이
&nbsp;일단 재귀적 호출을 통해서 완전탐색을 실행해 볼 수 있다. 여기에 메모이제이션을 이용하면 m일이 남았을 때 우물의 맨 위까지 도달할 수 있는 경우의 수와 확률을 저장하면 문제를 해결할 수 있을 것 같다.

### 풀이
&nbsp;가능한 m일 간 날씨의 조합은 모두 2^m가지다. 또한 비가올 확률이 50%이기 때문에 조합의 합이 n이상인 조합의 수를 센 뒤, 전체 조합의 수인 2^m으로 나누면 간단하게 계산할 수 있다.

### 완전 탐색 알고리즘
&nbsp;달팽이가 days일 동안 climbed미터를 기어올라 왔을 때 m일 전까지 n미터 이상 깅오를 수 있는 경우의 수를 계산한다.

```c++
int n, m;
int cache[MAX_N][2 * MAX_N + 1];
// 달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때, m일 전까지 n미터를 기어올라갈 수 있는 경우의 수
int climb(int days, int climbed) {
  // 기저 사례: m일이 모두 지난 경우
  if(days == m) return climbed >= n ? 1 : 0;
  // 메모이제이션
  int& ret = cache[days][climbed];
  if(ret != -1) return ret;
  return ret = climb(days + 1, climbed + 1) + climb(days + 1, climbed + 2);
}
```

### 예제: 장마가 찾아왔다(문제 ID: SNAIL, 난이도: 하)
&nbsp;여름 장마가 찾아와 비올 확률이 75%로 올라갔다고 하자. 이런 경우에는 경우의 수를 계산하지 않고 직접 확률을 계산한다. climb2(days + 1, climbed) = 달팽이가 지금가지 days일 동안 climbed미터를 기어올라 왔을 때 m일 전까지 n미터 이상 기어올라갈 수 있을 확률이라한다. 따라서 다음과 같은 점화식을 얻을 수 있다.

> climb2(days, climbed) = 0.75 * climb2(days + 1, climbed + 1) + 0.25 * climb2(days + 1, climbed + 2)

## 12. 문제: 비대칭 타일링(문제 ID: ASYMTILING, 난이도: 하)
&nbsp;그림과 같이 2 * n 크기의 직사각형을 2 * 1 크기의 타일로 채우려고 합니다. 타일들은 서로 겹쳐서는 안 되고, 90도로 회전해서 쓸 수 있습니다. 단 이 타일링 방법은 좌우 대칭이어서는 안 됩니다. 위 그림은 2 * 5 크기의 직사각형을 채우는 비대칭 타일링 방법 6가지를 보여줍니다. 다음의 2가지는 좌우대칭이기 때문에 세지 않습니다. n 이 주어질 때 가능한 비대칭 타일링 방법의 수를 계산하는 프로그램을 작성하세요. 방법의 수는 매우 클 수 있으므로, 1,000,000,007 로 나눈 나머지를 출력합니다.

### 시간 및 메모리 제한
&nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어집니다. 그 후 각 줄에 사각형의 너비 n (1 <= n <= 100) 이 주어집니다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에 비대칭 타일링 방법의 수를 1,000,000,007 로 나눈 나머지를 출력합니다.

### 개인적 풀이
&nbsp;n이 홀수인 경우 중앙 타일을 일자로 세우는 경우 대칭이 될 수 있고, 짝수인 경우 중앙 타일을 만들지 않거나 중앙 2 * 2만큼 크기의 공간을 채우는 경우 대칭이 될 수 있다. 그래서 모든 경우의 수를 구한 다음 홀수인 경우 int형 n / 2로 만들수 있는 타일링의 경우의 수를 빼주면 될 것 같다. 짝수에서도 n / 2로 만들 수 있는 경우의 수와 (n / 2) - 1로 만들 수 있는 경우의 수를 빼주면 될 것 같다.

## 13. 풀이: 비대칭 타일링

### 완전 탐색의 함정
&nbsp;이 문제를 직접적으로 풀기보다 좀더 단순화된 문제의 해법을 이용해서 더 쉽게 풀 수 있는 경우가 있다. 모든 타일링은 대칭이거나 비대칭이다. 대칭 타일링의 수를 세는 첫 번째 단계는 n이 짝수인 경우와 홀수인 경우를 각각 나눠 보는 것이다. n이 홀수이면 항상 정가운데 있는 세로줄은 세로 타일 하나로 덮여야만 한다. n이 짝수인 경우, 정가운데 세로줄 둘을 가로 타일로 덮고 나머지 절반이 서로 대칭인 경우와, 절반으로 나뉜 부분들이 서로 대칭인 경우.

```c++
// 2* width 크기의 사격형을 채우는 비대칭 방법의 수를 반환한다.
int asymmetric(int width) {
  if(width % 2 == 1)
    return(tiling(width) - tiling(width / 2) + MOD) % MOD;
  int ret = tiling(width);
  ret = (ret - tiling(width / 2) + MOD) % MOD;
  ret = (ret - tiling(width / 2 - 1) + MOD) % MOD;
  return ret;
}
```

### 직접 비대칭 타일링의 수 세기
&nbsp; 양쪽 끝에서부터 동시에 만들어 나가면 메모이제이션을 이용할 수 있다.

```c++
int cache2[101];
// 2 * width크기의 사각형을 채우는 비대칭 방법의 수를 반환한다.
int asymmetric2(int width) {
  // 기저 사례: 너비가 2 이하인 경우
  if(width <= 2) return 0;
  // 메모이제이션
  int& ret = cache2[width];
  if(ret != -1) return ret;
  ret = asymmetric2(width - 2) % MOD;
  ret = (ret + asymmetric2(width - 4)) % MOD;
  ret = (ret + tiling(width - 3)) % MOD;
  ret = (ret + tiling(width - 3)) % MOD;
}
```

### 스캐폴딩으로 테스트하기
&nbsp;정답임을 확실히 알 수 있는 알고리즘이 존재하기 대문에 스캐폴딩을 통해 테스트하기 아주 적절한 문제다.

## 14. 문제: 폴리오미노(문제 ID: POLY, 난이도: 중)
&nbsp;정사각형들의 변들을 서로 완전하게 붙여 만든 도형들을 폴리오미노(Polyomino)라고 부릅니다. n개의 정사각형으로 구성된 폴리오미노들을 만들려고하는데, 이 중 세로로 단조(monotone)인 폴리오미노의 수가 몇 개나 되는지 세고 싶습니다. 세로로 단조라는 말은 어떤 가로줄도 폴리오미노를 두 번 이상 교차하지 않는다는 뜻입니다. 예를 들어 그림 (a)는 정상적인 세로 단조 폴리오미노입니다. 그러나 (b)는 점선이 폴리오미노를 두 번 교차하기 때문에 세로 단조 폴리오미노가 아닙니다. (c)는 맨 오른쪽 아래 있는 정사각형이 다른 정사각형과 변을 완전히 맞대고 있지 않기 때문에 폴리오미노가 아닙니다. n개의 정사각형으로 구성된 세로 단조 폴리오미노의 개수를 세는 프로그램을 작성하세요.

### 시간 및 메모리 제한
&nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 그 후 각 줄에 폴리오미노를 구성할 정사각형의 수 n (1≤n≤100)이 주어집니다.

### 출력
&nbsp;각 테스트 케이스마다, n개의 정사각형으로 구성된 세로 단조 폴리오미노의 수를 출력합니다. 폴리오미노의 수가 10,000,000 이상일 경우 10,000,000으로 나눈 나머지를 출력합니다.

### 개인적 풀이
&nbsp;n개중 p개를 뽑는데, p의 총 합이 n이 될때까지 뽑는다. 또한 재귀적 호출을 할 때 값에 p를 곱해서 return한다.

```c++
int cache[101][101];

int polyCount(int n, int use) { }
```

## 15. 풀이: 폴리오미노

### 완전 탐색에서 시작하자
&nbsp;같은 모양의 폴리오미노를 두 번 이상 세면 안된다. 각 가로줄마다 몇 개의 정사각형을 넣을지를 결정하고, 이들을 왼쪽 - 오른쪽으로 적절히 밀어 주면 모든 폴리오미노를 만들 수 있다. 첫 줄에 i개의 정사각형이 속한 폴리오미노의 개수는 나머지 n - i개로 구성된 정사각형들로 폴리오미노를 만든 뒤, 이들을 적절히 맨 윗 줄 아래에 붙여 주면 된다. poly(n) 는 n개의 정사각형으로 만들 수 있는 세로 단조 폴리오미노의 수를 반환한다. 하지만 경우의 수를 정확히 계산 하기 위해서는 첫 줄에 있는 정사각형의 수 별로 폴리오미노의 수를 반환받을 수 있어야 한다. poly(n first)는 n개의 정사각형을 포함하되, 첫 줄에 first개의 정사각형이 들어가는 폴리오미노의 수.

```c++
const int MOD = 10 * 1000 * 1000;
int cache[101][101];
// n개의 정사각혀으로 이루어졌고, 맨 위 가로줄에 first개의 정사각형을 포함하는 폴리오미노의 수를 반환한다.
int poly(int n, int first) {
  // 기저 사례: n == first
  if(n == first) return 1;
  // 메모이제이션
  int& ret = cache[n][first];
  if(ret != -1) return ret;
  ret = 0;
  for(int second = 1; second <= n - first; ++second) {
    int add = second + first - 1;
    add *= poly(n - first, second);
    add %= MOD;
    ret += add;
    ret %= MOD;
  }
  return ret;
}
```

## 16. 문제: 두니발 박사의 탈옥(문제 ID: NUMB3RS, 난이도: 중)
&nbsp;위험한 살인마 두니발 박사가 감옥에서 탈출했습니다. 수배지를 붙이고 군경이 24시간 그를 추적하고 있지만 용의주도한 두니발 박사는 쉽사리 잡히지 않았습니다. d일이 지난 후에야 경찰은 프로그래밍의 천재인 찰리 교수)를 찾아왔습니다. 찰리 교수는 두니발 박사가 감옥에 남겨둔 노트를 분석해 다음과 같은 가설을 세웠습니다.

* 두니발 박사는 검문을 피해 산길로만 이동한다.
* 두니발 박사는 교도소를 탈출한 당일, 교도소와 인접한 마을 하나로 도망쳐 은신한다.
* 두니발 박사는 수색을 피하기 위해 그 후 매일 인접한 마을로 움직여 은신한다.

이 가설을 검증하기 위해 교도소로부터 산길로 연결된 n 개 마을들의 지도를 위 그림과 같이 구했습니다. 두니발 박사가 이 가설에 맞춰 행동하고, 움직일 수 있는 마을이 여러 개 있을 경우 그 중의 하나를 임의로 선택한다고 합시다. d 일 후에 두니발 교수가 각 마을에 있을 확률을 계산하는 프로그램을 작성하세요. 예를 들어 위 지도에서 3번 마을에 교도소가 있다고 합시다. 탈옥 직후 두니발 교수는 0번, 1번, 2번, 4번, 5번 중의 한 도시를 임의로 골라 도망칩니다. 따라서 1일 후에 두니발 교수가 0번 마을에 숨어 있을 확률은 1/5이고, 2일 후에 1번 마을에 숨어 있을 확률은 1/15입니다.

### 시간 및 메모리 제한
&nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 c (1 <= c <= 50) 가 주어집니다. 그 후 각 줄에 지도에 포함된 마을의 수 n (2 <= n <= 50) 과 탈출 후 지금까지 지난 일수 d (1 <= d <= 100), 그리고 교도소가 있는 마을의 번호 p (0 <= p < n) 가 주어집니다. 마을은 0번부터 n-1 번까지 순서대로 번호가 매겨져 있습니다. 그 후 n 줄에는 각각 n 개의 정수로 행렬 A 가 주어집니다. i 번 행의 j 번 숫자 A[i][j] 가 1인 경우 i 번 마을에서 j 번 마을을 잇는 산길이 있다는 것을 의미하며, 0인 경우 길이 없다는 것을 의미합니다. 그 다음 줄에 확률을 계산할 마을의 수 t (1 <= t <= n) 가 주어지고, 그 다음 줄에 t 개의 정수로 확률을 계산할 마을의 번호 q (0 <= q < n) 가 주어집니다.

### 출력
&nbsp;각 테스트 케이스마다 t 개의 실수로 각 마을에 두니발 박사가 숨어 있을 확률을 출력합니다. 10^-7 이하의 절대/상대 오차가 있는 경우 정답으로 처리됩니다.

## 17. 풀이: 두니발 박사의 탈옥
&nbsp;가능한 한 모든 시나리오들을 다 만들어 보고 그들의 확률을 계산해서 더하면 될 것 같다.

### 역시 완전 탐색에서 시작하자
&nbsp;p에서 시작해 n번 인접한 마을로 옮기는 모든 경로를 생성하고, 이 중 q에서 끝나는 것들이 출현할 확률을 계산해 그들의 합을 반환한다.

### 메모이제이션
&nbsp;메모이제이션을 이용하기 위해 다음과 같은 것을 적용해 본다.

* path대신 현재 위치 here와 탈옥 후 지난 날짜 days를 재귀 호출에 전달한다.
* 전체 경로의 확률을 계산하는 것일 아니라, 현재 위치에서 시작해서 남은 날짜 동안 움직여 q에 도달할 확률을 계산한다.

search2(here, days) = 두니발 박사가 days일째에 here번 마을에 숨어 있을 때, 마지막 날에 q번 마을에 있을 조건부 확률을 반환한다.

### 조건부 확률
앞으로 선택하는 조각들에 대한 답 만 반환한다는 원칙에 잘 맞는다.

### 구현

```c++
int n, d, p, q;
// cache[][]는 -1로 초기화해 둔다.
double cache[51][101];
// connected[i][j] = 마을 i, j가 연결되어 있나 여부
// deg[i] = 마을 i와 연결된 마을의 개수
int connected[51][51], deg[51];
// days일째에 here번 마을에 숨어 있다고 가정하고, 마지막 날에는 q번 마을에 숨어 있을 조건부 확률을 반환한다.
double search2(int here, int days) {
  // 기저 사례: d일이 지난 경우
  if(days == d) return (here == q ? 1.0 : 0.0);
  // 메모이제이션
  double& ret = cache[here][days];
  if(ret > -0.5) return ret;
  ret = 0.0;
  for(int there = 0; there < n; ++there)
    if(connected[here][there])
      ret += search2(there, days + 1) / deg[here];
  return ret;
}
```

### 반대 방향에서 풀기
&nbsp;계산의 순서를 반대 방향으로 바꾸면 더 빠르게 구현이 가능하다. search3(here, days)는 탈옥 후 days일째에 두니발 박사가 here번 마을에 숨어 있을 확률이다.

```c++
int n, d, p, q;
double cache[51][101];
// connected[i][j] = 마을 i, j가 연결되어 있나 여부
// deg[i] = 마을 i와 연결된 마을의 개수
int connected[51][51], deg[51];
double search3(int here, int days) {
  // 기저 사례: 0일째
  if(days == 0) return (here == p ? 1.0 : 0.0);
  // 메모이제이션
  double& ret = cache[here][days];
  if(ret > -0.5) return ret;
  ret = 0.0;
  for(int there = 0; there < n; ++there)
    if(connected[here][there])
      ret += search2(there, days - 1) / deg[there];
  return ret;
}
```

### 이론적 배경: 마르코프 연쇄
&nbsp;마르코프 연쇄(Markov Chain)는 현실 세계의 많은 현상들을 모델링하기 위해 종종 사용되는 유용한 모델이다.