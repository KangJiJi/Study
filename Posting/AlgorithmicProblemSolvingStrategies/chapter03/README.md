3장 코딩과 디버깅에 관하여
========================

## 01. 도입
&nbsp;어떤의미에서는 코딩 능력이 가장 중요하다. 대회 상위 입상자들의 코드에서 시간에 쫓겨 작성한 흔적을 찾기란 쉽지 않다. 이장에서는 코딩, 디버깅 노하우와 자주하는 실수들에 관해 다룬다.

## 02. 좋은 코드를 짜기 위한 원칙
&nbsp;일반적으로 실무에서 좋은 코드의 원칙이라고 할만한 것들 또한 대부분 프로그래밍 대회에서도 적용된다.

### 간결한 코드를 작성하기
&nbsp;전역 변수의 광범위한 사용은 지양해야 한다. 또한 아래와 같이 매크로를 사용해 간결한 코드를 작성할 수 있다.

```c++
#define FOR(i, n) for(int i = 0; i < (n); ++i);
```

이런 코드로 인해서 다음과 같은 실수를 피할 수 있다.

```c++
for(int j = 0; j < i; ++i); //++j 여야 함
```

### 적극적으로 코드 재사용하기
&nbsp;코드를 모듈화 하면 간결한 코드 작성이 가능해 진다. 같은 코드가 세 번 이상 등장한다면 함수로 분리해라.

### 표준 라이브러리 공부하기
&nbsp;표준 라이브러리는 셀 수 없을 정도로 많이 사용되고 검증되었기 때문에, 메모리 관리나 정당성 증명에 신결 쓸 필요 없이 편하게 사용할 수 있다.

### 항상 같은 형태로 프로그램을 작성하기
&nbsp;매번 다른 코드를 작성하면 검증하는 여유를 부리기가 힘들고 이는 피같은 디버깅 시간으로 연결된다.

### 일관적이고 명료한 명명법 사용하기
&nbsp;모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익혀라.

### 모든 자료를 정규화해서 저장하기
&nbsp;같은 자료를 두 가지 형태로 저장하지 않는다.

### 코드와 데이터를 분리하기
&nbsp;날짜를 출력할 떄 월을 숫자가 아니라 영문으로 출력해야 한다 가정한다. 다음과 같은 12줄 짜리 함수를 짤 수 있다.

```c++
string getMonthName(int month) {
  if(month == 1) return "January";
  if(month == 2) return "February";
  ...
  return "December";
}
```

이런 코드는 피해야 한다. 코드의 논리와 상관이 없는 데이터는 가능한 한 분리해서 사용해야 한다.

```c++
const string monthName[] = {"January", "February", ... ,"December"};
```

이런 방식은 항상 코드의 양을 줄여서 실수를 하지 않게 도와준다.

## 03. 자주 하는 실수
&nbsp;실수에서 배우고 유사한 실수를 저지르지 말아야 한다.

### 배열 범위 밖 원소에 접근
&nbsp;배열 범위 밖의 원소에 접근하려 하면 당연히 오류가 뜬다. 오류 나지 않으면서도 틀린 답을 내놓는 경우도 있다. 다음과 같은 변수 선언을 보자.

```c++
int array[10], t;
```

만약 array와 t가 메모리 상에 연속해서 위치하게 됐다고 가정한다. 이때 array[10]에 값을 대입하면 t에 값이 들어간다. 이 접근은 어떤 런타임 에러도 나지 않으며, 매우 찾기 어려운 버그가 된다. 이를 해결하기 위한 방법으로는 JS의 map이나 forEach를 사용하거나 위에서 나온 FOR과 같은 매크로를 사용하면 된다.

### 일관되지 않은 범위 표현 방식 사용하기
&nbsp;닫힌 구간(closed interval), 열린 구간(open interval), 반 열린 구간(half-open interval)중 하나만 사용하자. 각가의 구간은 장단점이 있다. 하지만 프로그래밍 언어가 지원하는 범위 표현 방식을 따르는 것이 가장 효율적이다.

### Off-by-one 오류
&nbsp;Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가리킨다. 이런 오류를 방지할 수 있는 좋은 방법은 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 것이다.

### 컴파일러가 잡아주지 못하는 상수 오타
&nbsp;각종 상수를 잘못 입력해서 문제를 잘 풀어 놓고도 오답 처리되는 경우가 종종 있다. 문제를 잘보거나, 자신이 사용하는 언어에서 상수의 타입을 어떻게 지정하는지 이런 경우들에 대해서 잘 알아 두는 것이 좋다.

### 스택 오버플로
&nbsp;콜 스택이 오버플로해서 프로그램이 강제 종료되는 것 또한 흔히 하는 실수이다. 대개 재귀 호출의 깊이가 너무 깊어져서 오는데 이런 점은 늘 유의하는 것이 좋다.

### 다차원 배열 인덱스 순서 바꿔 쓰기
&nbsp;4, 5차원 이상의 고차원 배열을 사용할 때 인덱스의 순서를 헷갈려서 잘못 쓰는 일이 흔히 있다. 이런 경우에는 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다.

### 잘못된 비교 함수 작성
&nbsp;< 연산자의 성질을 알지 못하고 오버로딩을 하게 되면 잘 작동 하지 못하는 코드를 만들 수 있다. 또한 자바의 표준 라이브러리가 < 연산 대신 <= 연산을 비교 함수의 모델로 쓰기 때문에 자신이 사용하는 언어의 특징을 알아야 한다.

### 최소, 최대 예외 잘못 다루기
&nbsp;코드를 짤 때 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지를 생각해 보면 오류를 잡을 수 있는 경우가 꽤 있다. 0과 1같은 경우도 잘 생각해서 코딩해야 한다.

### 연산자 우선순위 잘못 쓰기
&nbsp;시프트 연산자나 비트 단위 연산자들의 우선순위는 종종 헷갈리게 만든다.

```c++
if(b & 1 == 0); // == 연산자 순위가 더 높다 b & (1 == 0)
```

연산자 우선 순위가 헷갈릴 경우에는 괄로로 적절히 감싸는 것을 잊지 말자.

### 너무 느린 입출력 방식 선택
&nbsp;C++에서는 gets()를 이용해서 모든 입력을 문자열 하나로 읽어들인 뒤 파싱할 수도 있고, cin 등의 고수준 입력 방식을 사용할 수도 있다. 고수준 입출력 방식을 이용하면 코드는 간단해지지만, 속도 저하가 크다. 입력으로 받거나 출력해야 할 변수의 수가 1만 개를 넘어가면 긴장하는 것이 좋다.

### 변수 초기화 문제
&nbsp;흔한 실수중 하나는 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것이다. 완전하지는 않지만 이런 실수를 예방하기 위한 팁 하나는 예제 입력 파일을 두 번 반복해 쓰는 것이다.

## 04. 디버깅과 테스트

### 디버깅에 관하여
&nbsp;디버거는 유용한 도구이지만, 눈으로 디버깅하는 쪽이 훨씬 빠른 경우가 적지 않다. 또한 재귀 호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거로 디버깅하기에 적당하지 않다. 디버거를 사용하는 대신 작은 입력에 대해 제대로 실행되나 확인하고, 단정문을 쓰고, 프로그램의 계산 중간 결과를 출력하게 만들어 보는 방법이 있다. 이래도 모르겠다면 디버거를 사용해도 좋을 것 같다.

### 테스트에 관하여
&nbsp;예제 입력을 만들어 가능한 한 많이 프로그램을 테스트 하는 것이 좋다. 프로그램 테스트 기법으로 스캐폴딩이 있다. 수십만, 수백만 개의 입력을 자동으로 테스트 할 수 있게 코드를 짜는 것이다. 작은 입력에서만 동작하는 더 느리지만 단순한 알고리즘을 사용해 답안을 검증하면 된다. 시간 소요가 많기 때문에 꼭 필요한 경우에만 사용하는게 좋다.

## 05. 변수 범위의 이해

### 산술 오버플로
&nbsp;어떤 식의 계산 값이 반횐되는 자료형의 표현 가능한 범위를 벗어나는 경우다. 가장 흔한 실수중 하나이다. 다음은 산술 오버플로가 등장하는 대표적인 경우다.

### 너무 큰 결과
&nbsp;결과는 64비트 정수를 사용해야 하는데 습관적으로 32비트 정수를 사용해 일어나는 실수는 흔한 실수 이다. 큰 정수를 다룰 때는 항상 변수의 형태에 주의하는 습관을 들이자.

### 너무 큰 중간 값
&nbsp;출력의 값은 작지만 중간 과정에서 큰 값을 일시적으로 계산해야 하는 경우가 있다. 예를 들어 a, b의 최소 공배수는 (a * b) / (a, b의 최대 공약수) 로 계산이 가능하다. 이를 코드로 나타내면 이렇게 된다.

```c++
int gcd(int a, int b); // 두 수의 최대공약수를 반환한다.

int lcm(int a, int b) {
  return (a * b) / gcd(a, b);
};
```

별 문제 없어보이지만 lcm(50000, 100000)을 계산하게 되면  a * b의 값이 5 * 10^9이기 때문에 32비트 정수형의 최대치를 가뿐히 넘어간다. 코드의 논리를 보는 것만으로는 이런 버그를 찾기가 힘들다.

### 너무 큰 '무한대' 값
&nbsp;프로그램을 짜다 보면 무한대에 해당하는 큰 값을 이용하는 것이 편리할 때가 있다. 만약 S에서 T까지 가는데 a, b, c중 항상 한군데를 거쳐 가야 한다할 때 b가 T랑 연결 돼 있지 않다면 b랑 T의 연결 거리를 아주 큰값을 넣으면 min을 계산하는 과정에서 자동으로 걸러지기 때문에 유용하다. 큰값으로 987,654,321을 이용하는 것을 추천한다.

### 오버플로 피해가기
&nbsp;오버플로를 피해가기 위한 방법중 하나는 더 큰 자료형을 사용하는 것이다. 또한 연산의 순서를 바꾸는 방법도 있다. 아래의 코드를 보자.

```c++
int lcm(int a, int b) {
  return a * (b / gcd(a, b));
}
```

이런식으로 연산의 순서를 바꿔주는 것만으로도 오버플로를 피할 수 있다. 문제에 따라 계산 방법을 다르게 해 오버플로를 피해가는 방법도 있다. 예를 들어 이항 계수를 계산할 때 점화식을 이용해서 계산하는 경우가 있다.

### 자료형의 프로모션
&nbsp;피연산자의 자료형이 다르거나 자효형의 범위가 너무 작은 경우 컴파일러들은 대개 이들을 같은 자료형으로 변환해서 계산하는데, 이를 프로모션이라고 한다. 다음 코드를 보자.

```c++
unsigned char a = 17;
short b = -18;
int c = 2;
unsigned int d = 0;

cout << (a + b) * c + d << endl;
```

출력값이 -2가 나와야 하지만 4,294,967,294라는 말도 안 되는 값이 출력된다. 이유는 d를 더하면서 -2를 d에 대입하는 과정에서 오버플로가 일어나, 값이 강제로 부호 없는 정수로 캐스팅되는 과정에서 큰 값이 되는 것이다.

### 실수 자료형의 이해

### 실수 연산의 어려움
&nbsp;컴퓨터가 사용하는 실수 표현 방식에 대해 알아보자.

### 실수와 근사 값
&nbsp;컴퓨터에서 정수는 정확하게 표현할 수 있다. 하지만 파이와 같은 실수는 무한하다. 따라서 컴퓨터의 모든 실수 변수는 정확도가 제한된 근사 값을 저장한다.

### IEEE 754 표준
&nbsp;많은 컴퓨터/컴파일러들에서 사용되는 실수 표기 방식은 IEEE 754표준을 따르고 있다. IEEE 754은 이진수로 실수를 표기 하며, 부동 소수점 표기법을 이용하고, 무한대, 비정규 수, NaN등의 특수 값이 존재 한다는 큰 특징이 있다.

### 실수의 이진법 표기
&nbsp;이진법으로 쓴 실수 1011.101은 2^3 + 2^1 + 2^0 + 2^(-1) + 2^(-3) = 11.625 가 된다.

### 부동 수소점 표기
&nbsp;IEEE 754를 포함한 대부분의 실수 표준에서는 소수점을 옮길 수 있도록 했다. 예를 들어 11.625는 이진법으로 쓰면 1011.101이 된다. 이때 소수점을 왼쪽으로 세 칸 옮기면 1.011101이 되고, 이 수를 맨 앞에서부터 저장 공간이 허락하는 만큼 저장하는 것이다. 맨 앞 소수점 앞에 있는 1은 빼고 나머지를 저장한다. 이렇게 부호 비트, 지수, 가수로 나눠서 이진수로 표현하게 된다.

### 실수 비교하기
&nbsp;1/10 * 3과 3/10이 같은지 비교한다고 할 때, 1/10과 3/10은 둘다 실수 변수에 정확하게 담을 수 없으며, 근사값으로 표현된다. 따라서 1/10 * 3이 3/10보다 약간 더 커지게 된다. 따라서 두 값의 차이가 매우 작은 경우 두 값이 같다고 판단해야 한다. 다음과 같이 구현할 수 있다.

```c++
bool absoluteEqual(double a, double b) {
  return fabs(a - b) < 1e-10;
}
```

하지만 (10^20 / x) * x와 10^20이 같은지 확인 할 때는 absoluteEqual()은 안전하지 않다. 오차가 매우 크기 때문이다. 이런경우 두 가지 방법이 있다.

### 하나. 비교할 실수의 크기들에 비례한 오차 한도를 정한다
&nbsp;실제 입력으로 들어올 최대 값과 최소 값을 대략 예측할 수 있고, 이들이 크게 차이 나지 않는 경우에는 하나의 오차 한도 값을 사용할 수 있다. 오차의 한도를 적절히 선택하자.

### 둘. 상대 오차를 이용한다.
&nbsp;두 수 a, b의 상대 오차를 다음과 같이 정의한다.

```c++
bool relativeEqual(double a, double b) {
  return fabs(a - b) <= 1e-8 * max(fabs(a), fabs(b));
}
```

이때 비교식의 좌변은 두 수의 절대 차이를 나타내고, 오른쪽은 두 수 중 절대 값이 더 큰 수에 0.000001%를 곱한것을 나타낸다. 하지만 이런한 구현도 매우 작은 숫자들을 비교하려 할 때는 문제가 될 수 있다. 따라서 오차가 매우 작을 경우 무조건 참을 반환하는 조건문을 추가한다.

```c++
bool doubleEqual(double a, double b) {
  double diff = fabs(a - b);
  if(diff < 1e-10) return true;
  return diff <= 1e-8 * max(fabs(a), fabs(b));
}
```

### 대소 비교
&nbsp;대소 비교에서도 두 값이 아주 가까운 경우를 먼저 확인하고 처리해 주어야 한다.

### 정확한 사칙연산
&nbsp;실수 변수라 해서 항상 그 값이 정확하지 않은 것은 아니다. 따라서 일정 범위와 크기를 갖는 숫자를 다룰 경우에는 사칙연산이 항상 정확하게 이루어진다.

### 코드의 수치적 안정성 파악하기
&nbsp;수치적으로 안정적인 코드에서는 실수의 정확도 문제를 고려하지 않아도 된다.

### 실수 연산 아예 하지 않기
&nbsp;실수 연산을 제대로 하는 가장 좋은 방법은 아예 실수 연산을 하지 않는 것이다. 예를 들어 a / b * c는 (a * c) / b형태로 수식을 바꿈으로서 실수 연산을 쓰지 않고 결과를 계산할 수 있다. 또한 양변을 제곱 하거나 여러 방법으로 실수 계산을 피할 수 있다.