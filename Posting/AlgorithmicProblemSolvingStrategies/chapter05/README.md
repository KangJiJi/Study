5장 알고리즘의 정당성 증명
=========================

## 01. 도입

### 알고리즘의 정당성 증명
&nbsp;많은 경우 증명이 알고리즘을 유도하는 데 결정적인 통찰을 담고 있다. 이 장에서는 알고리즘의 정당성 증명에서 흔히 나타나는 패턴들을 소개하고 몇 가지의 예제 증명들을 다룬다.

## 02. 수학적 귀납법과 반복문 불변식
&nbsp;귀납법 증명은 크게 세 단계로 나누어 진다.

* 단계 나누기
* 첫 단계 증명
* 귀납 증명

> 고등 수학에 나오는 귀납적 증명.

귀납법을 이용한 증명의 예로 사다리 게임을 살펴 보자.

#### 단계 나누기
&nbsp;N개의 세로줄에서부터 시작해서 원하는 사다리가 될 때까지 하나씩 가로 줄을 그어 간다. 이떄 가로 줄을 하나 긋는 것을 한 단계라 한다.

#### 첫 단계 증명
&nbsp;텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 된다.

#### 귀납 증명
&nbsp;가로줄을 그어서 두 개의 세로줄을 연결했다고 하자. 이때 두 세로줄의 결과는 서로 뒤바뀐다. 1:1 대응은 변하지 않으므로 다음 단계에서도 1:1 속성이 유지 된다.

따라서 귀납법에 의해 가로줄만을 사용하는 사다리들은 항상 1:1로 대응이 된다.

### 반복문 불변식
&nbsp;귀납법을 이용해 알고리즘의 정당성을 증명할 때는 반복문 분변식(loop in variant)이라는 개념이 유용하게 쓰인다. 반복문 불변식이란 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건이다. 불변식을 이용하면 반복문의 정당성을 다음과 같이 증명할 수 있다.

* 반복문 진입시에 불변식이 성립함을 보인다.
* 반복문 내용이 불변식을 깨뜨리지 않음을 보인다.
* 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.

### 이진 탐색과 반복문 불변식

```c++
// A는 오름차순 정렬
// A[i - 1] < x <= A[i]인 i를 반환한다.
int binsearch(const vector<int>& A, int x) {
  int n = A.size();
  int lo = -1, hi = n;
  // 반복문 불변식: lo < hi
  // 반복문 불변식: A[lo] < x <= A[hi]
  while(lo + 1 < hi) {
    int mid = (lo + hi) / 2;
    if(A[mid] < x)
      lo = mid;
    else
      hi = mid;
    // 불변식은 여기서도 성립해야 한다.
  }
}
```

### 삽입 정렬과 반복문 불변식

```c++
void insertionSort(vector<int>& A) {
  for(int i = 0; i < A.size(); ++i) {
    // 불변식 a: A[0..i - 1]은 이미 정렬되어 있다.
    // A[0..i-1]에  A[i]를 끼워 넣는다.
    int j = i;
    while(j > 0 && A[j - 1] > A[j]) {
      // 불변식 b: A[j + 1..i]의 모든 원소는 A[j]보다 크다.
      // 불변식 c: A[0..i]구간은 A[j]를 제외하면 정렬되어 있다.
      swap(A[j - 1], A[j]);
      --j;
    }
  }
}
```

### 단정문을 이용해 반복문 불변식 강제하기
&nbsp;불변식을 단정문으로 강제해 버리면 해당 불변식이 깨졌을 때 프로그램이 강제 종료되기 때문에 불변식의 유지에 문제가 있다는 사실은 아주 쉽게 알 수 있다.

## 03. 귀류법
&nbsp;우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법을 귀류법이라고 한다.

### 책장 쌓기
&nbsp;각 책장마다 버틸 수 있는 최대 문게 M과 자신의 무게 W가 주어질 떄, 책장을 가장 높이 쌓는다면 몇 개나 쌓을 수 있을까? 결론부터 말하자면 M + W가 큰 것부터 아래에 놓아야 한다.

### 귀류법을 이용한 증명들
&nbsp;각 단계에서 최선의 선택을 함을 귀류법으로 증명하고, 각 단계에서 최선의 선택을 한다면 다음 단계에서도 최선의 선택을 할 수 있음을 귀납법으로 증명하는 것이다.

## 04. 다른 기술들

### 비둘기집의 원리
&nbsp;10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어간 비둘기집이 반드시 하나는 있게 마련이다.

### 동전 뒤집기
&nbsp;100개의 동전이 바닥에 깔려 있는데 이 중 F개는 앞면, 100 - F개는 뒷면이다. 이 동전 모두를 앞면으로 뒤집고 싶은데 한 번 뒤집을 때 반드시 X개의 동전을 한꺼번에 뒤집어야 한다. 이때 뒤집는 횟수를 최소화하고 싶다. 답의 상한은 얼마일까? 정답은 100이다. 어떤 답에서 동전을 101번 뒤집었다면 비둘기집의 원리에 의해서 최선의 답이 아니다.

### 순환 소수 찾기
&nbsp;무한 소수라는 사실을 알기 위해서 비둘기집의 원리를 사용한다.

### 구성적 증명
&nbsp;구성적 증명은 답의 실제 예를 들거나 답을 만드는 방법을 실제로 제시하는 증명이다. 내용은 사실상 알고리즘인 경우가 많다.

### 안정적 결혼 문제
&nbsp;이 문제는 구성적 증명으로 답이 존재 함을 보일 수 있다.