10장 탐욕법
===========

## 1. 도입
&nbsp;탐욕법(greedy method)는 가장 직관적인 알고리즘 설계 패러다임 중 하나다. 완전 탐색이나 동적 계획법 알고리즘은 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는다. 하지만 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 탐욕적 알고리즘은 많은 경우 최적해를 찾지 못하기 때문에 다음과 같은 경우에 사용한다.

* 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, 탐욕법은 동적 계획법보다 수행 시간이 훨씬 빠르기 때문에 유용한다.
* 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신에 적당히 괜찮은 답을 찾는 것으로 타협할 수 있다. 탐욕법은 이럴 때 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다.

### 예제: 회의실 예약
&nbsp;탐욕법이 유용하게 사용되는 문제 중 유명한 예로 활동 선택 문제가 있다. 회사에 회의실이 하나밖에 없는데, n개의 팀이 각가 회의하고 싶은 시간을 제출했다고 한다. 두 팀이 회의실을 같이 쓸 수는 없기 때문에 이 중 서로 겹치지 않을 회의들만을 골라내서 진행해야 한다. 최대 몇 개나 선택할 수 있을까?

### 무식하게 풀 수 있을까?
&nbsp;이 문제를 무식하게 푸는 방법은 모든 부분 집합을 하나하나 만들어 보며 그중 회의들이 겹치지 않는 답들을 걸러내고 그중 가장 큰 부분 집합을 찾아낸다. 하지만 집합의 크기가 n일때 n이 30만 돼도 시간 안에 문제를 풀기는 힘들다.

### 탐욕적 알고리즘의 구상
&nbsp;이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 가장 먼저 끝나는 회의부터 선택하는 것이다.

### 정당성의 증명: 탐욕적 선택 속성
&nbsp;탐욕적 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가진다. 처음으로 증명해야 할 속성은 동적 계획법처럼 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것이다. 이 속성은 탐욕적 선택 속성(greedy choice property)이라고 부른다. 앞에서 제안한 알고리즘의 경우, 탐욕적 선택 속성이 성립하려면 다음 조건이 성립해야 한다. 가장 종료 시간이 빠른 회의(Smin)를 포함하는 최적해가 반드시 존재한다.

### 최적 부분 구조
&nbsp;항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 보여야 한다. 탐욕법의 정당성을 위해 증명해야 할 두 번쨰 속성은 최적 부분 구조(optimal substructure)이다. 부분 문제의 최적해에서 전체 문제의 최적해를 만들 수 있음을 보여야한다.

### 구현
&nbsp;처음에 모든 회의를 종료 시간의 오름차순으로 정렬해 두면 쉽고 빠르게 구현가능하다. 겹치는 회의를 지울 필요 없이, 정렬된 배열을 순회하면서 첫 번째 회의와 겹치지 않는 회의를 찾는다.

```c++
// 각 회의는 [begin,end) 구간 동안 회의실을 사용한다
int n;
int begin[100], end[100];
int schedule() {
	// 일찍 끝나는 순서대로 정렬한다
	vector<pair<int,int> > order;
	for(int i = 0; i < n; i++)
		order.push_back(make_pair(end[i], begin[i]));
	sort(order.begin(), order.end());
	// earliest: 다음 회의가 시작할 수 있는 가장 빠른 시간
	// selected: 지금까지 선택한 회의의 수
	int earliest = 0, selected = 0;
	for(int i = 0; i < order.size(); ++i) {
		int meetingBegin = order[i].second, meetingEnd = order[i].first;
		if(earliest <= meetingBegin) {
			// earliest 를 마지막에 회의가 끝난 시간 이후로 갱신한다
			earliest = meetingEnd;
			++selected;
		}
	}

	return selected;
}
```

### 난 동적 계획법으로 풀었는데?
&nbsp;물론 이 문제도 동적 계획법으로 풀 수 있다. 하지만 다른 문제에서 동적 계획법에 필요한 메모리나 시간이 과도하게 크기 때문에 탐욕법을 사용한다.

### 예제: 출전 순서 정하기(문제 ID: MATCHORDER, 난이도: 하)
&nbsp;전세계 최대의 프로그래밍 대회 알고스팟 컵의 결승전이 이틀 앞으로 다가왔습니다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 됩니다. 각 팀의 감독은 대회 전날, 주최측에 각 선수를 출전시킬 순서를 알려 주어야 합니다. 결승전 이틀 전, 한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈습니다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현합니다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정합시다. 표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 됩니다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있지요. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까요?

### 시간 및 메모리 제한
&nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 각 팀 선수의 수 N(1≤N≤100)가 주어집니다. 그 다음 줄에는 N개의 정수로 러시아팀 각 선수의 레이팅이 출전 순서대로 주어지며, 그 다음 줄에는 N개의 정수로 한국팀 각 선수의 레이팅이 무순으로 주어집니다. 모든 레이팅은 1 이상 4000 이하의 정수입니다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에 한국팀이 얻을 수 있는 최대 승수를 출력합니다.

### 개인적 풀이
&nbsp;러시아팀 레이팅을 오름차순으로 정렬한다. 이 정렬된 배열을 1번 순회하면서 각 레이팅 값보다는 더 크지만 차이가 가장 작은 한국팀 레이팅을 구한다.

```c++
int n, win;
vector<int> russia, korea;

int cheat() {
	for(int i = 0; i < russia.size(); i++) {
		int diff = 5000;
		for(int j = 0; j < korea.size(); j++) {
			if(russia[i] <= korea[j])
				diff = min(diff, korea[j] - russia[i]);
		}
		if(diff < 4000) win++;
	}
}
```

### 무식하게 풀 수 있을까?
&nbsp;n명의 선수가 있으니 이 문제에는 n!개의 답이 있다. 하지만 n이 조그만 커져도 답의 개수가 너무 많기 때문에 시간 안에 다 셀 수 없다.

### 그렇다면 동적 계획법은 어떨까?
&nbsp;order(taken)은 각 한국팀 선수를 이미 순서에 추가했는지의 여부가 taken에 주어질 때, 남은 선수들을 적절히 배치해서 얻을 수 있는 최대 승수라고 정의한다. 그러면 O(n * 2^n)시간의 동적 계획법 알고리즘을 얻을 수 있다.

### 탐욕적 알고리즘의 구상
&nbsp;탐욕적 알고리즘을 설계하는 좋은 방법은 간단하 입력을 몇 개 손으로 풀어보는 것이다. 맨 앞 경기부터 한 명씩 출전할 한국 선수를 정하도록 한다. 상대방 선수를 이길 수 있는 한국 선수가 있는 경우 그중 레이팅이 가장 낮은 선수를 상대방 선수와 경기시킨다. 만약 상대방 선수가 한국팀의 모든 선수보다 레이팅이 높다면 남은 선수 중 가장 레이팅이 낮은 선수와 경기 시킨다.

### 탐욕적 선택 속성 증명
&nbsp;우리가 선택한 방법을 포함하는 최적해가 있음을 증명하기 위해, 우선 우리가 선택한 방법을 포함하지 않는 최적해의 존재를 가정한다. 그리고 이것을 적절히 조작해 우리가 선택한 방법을 포함하는 최적해를 만들어 낸다.

### 구현

```c++
int order(const vector<int>& russian, const vector<int>& korean) {
	int n = russian.size(), wins = 0;
	//아직 남아 있는 선수들의 레이팅
	multiset<int> ratings(korean.begin(), korean.end());
	for (int rus = 0; rus < n; rus++) {
		//가장 레이팅이 높은 한국 선수가 이길 수 없는 경우
		//가장 레이팅이 낮은 선수와 경기시킨다.
		if (*ratings.rbegin() < russian[rus])
			ratings.erase(ratings.begin());
		//이 외의 경우 이길 수 있는 선수 중 가장 레이팅이 낮은 선수와 경기시킨다.
		else {
			ratings.erase(ratings.lower_bound(russian[rus]));
			wins++;
		}
	}
	return wins;
}
```

### 탐욕적 알고리즘 레시피
* 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
* 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다.
* 탐욕적 선택 속성과 최적 부분 구조를 증명해 본다.

## 02. 문제: 도시락 데우기(문제 ID: LUNCHBOX, 난이도: 하)

### 시간 및 메모리 제한
&nbsp;프로그램은 10초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (<= 300) 가 주어집니다. 각 테스트 케이스는 세 줄로 구성된다. 첫 줄에는 도시락의 수 n(1 <= n <= 10000)이 주어진다. 두 번쨰 줄에는 n개의 정수로 각 도시락을 데우는 데 걸리는 시간이 주어지며, 세 번째 줄에는 역시 n개의 정수로 각 도시락을 먹는데 걸리는 시간이 주어진다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에 점심을 먹는 데 걸리는 최소 시간을 출력한다.

## 03. 풀이: 도시락 데우기

### 최소화해야 할 값
&nbsp;한 도시락을 먹을 때까지 걸리는 시간은 지금까지 데운 모든 도시락을 데우는 시간의 합에 이 도시락을 먹는 데 걸리는 시간을 더한 것이다. 우리는 그중 가장 큰 값을 최소화하려고 한다.

### 탐욕적 알고리즘의 구상
&nbsp;모든 도시락을 먹는데 같은 시간 C가 걸린다고 가정해 본다. 그러면 어떤 순서로 도시락을 데우건 간에 점심 시간의 길이는 모든 도시락을 데우는 시간과 도시락 하나를 먹는 시간의 합이다. 왠지 데우는 시간과는 관련 없이 먹는 데 오래 걸리는 도시락부터 데우는 것이 정답일 것 같다.

### 탐욕적 선택 속성 증명
&nbsp;예를 들어 돈까스 도시락을 제일 먼저 데우는 최적해가 존재한다고 가정한다. 샤브샤브가 x번이고 x + 1번 이후의 도시락들 입장에선 순서를 바꾼다 해도 다를 것이 없다. 따라서 0번부터 x번까지의 도시락들만 고려한다. 샤브샤브가 가장 마지막에 있을 때가 max시간이다. 이제 남은 도시락들의 순서를 바꾸는데 아무리 바꿔도 max를 초과할 수 없다.

### 최적 부분 구조 증명
&nbsp;매 단계마다 최적의 선택을 해도 상관 없다.

### 구현

```c++
int n, e[MAX_N], m[MAX_N];
int heat() {
	//어느 순서로 데워야 할지를 정한다.
	vector<pair<int, int>> order;
	for (int i = 0; i < n; ++i)
		order.push_back(make_pair(-e[i], i));
	sort(order.begin(), order.end());
	//해당 순서대로 데워먹는 과정을 시뮬레이션한다.
	int ret = 0, beginEat = 0;
	for (int i = 0; i < n; ++i) {
		int box = order[i].second;
		beginEat += m[box];
		ret = max(ret, beginEat + e[box]);
	}
	return ret; 
}
```

## 04. 문제: 문자열 합치기(문제 ID: STRJOIN, 난이도: 중)
&nbsp;프로그래밍 언어 C 의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않는다는 것입니다. C 에서는 문자 배열로 문자열을 표현하되 \0 (NULL) 로 문자열의 끝을 지정하는데, 이래서는 문자열의 길이를 쉽게 알 수 있는 방법이 없기 때문에 여러 가지 문제가 발생하게 됩니다. 이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커진다는 것이 있습니다. 앞에 주어진 함수 strcat() 은 문자열 dest 뒤에 src 를 붙이는 함수인데, 실행 과정에서 반복문을 두 문자열의 길이를 합한 만큼 수행해야 합니다. 이 함수를 사용해 두 개의 문자열을 합치는 비용은 두 문자열의 길이의 합이라고 합시다. 이 함수를 이용해 n 개의 문자열을 순서와 상관없이 합쳐서 한 개의 문자열로 만들고 싶습니다. 순서가 상관 없다는 말은 {al,go,spot} 을 spotalgo 로 합치든 alspotgo 로 합치든 상관 없다는 의미입니다. 그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다. 예를 들어 먼저 al 과 go 를 합치고 (2+2=4), 이것을 spot 과 합치면 (4+4=8) 총 12 의 비용이 들지만 al 과 spot 을 합치고 (2+4=6) 이것을 다시 go 에 합치면 (6+2=8) 총 14 의 비용이 필요합니다. n 개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾는 프로그램을 작성하세요.

### 시간 및 메모리 제한
&nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

### 입력
&nbsp;입력의 첫 줄에는 테스트 케이스의 수 c (c <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 문자열의 수 n (1 <= n <= 100) 이 주어지며, 다음 줄에는 n 개의 정수로 각 문자열의 길이가 주어집니다. 각 문자열의 길이는 1,000 이하의 자연수입니다.

### 출력
&nbsp;각 테스트 케이스마다 한 줄에 모든 문자열을 합칠 때 필요한 최소 비용을 출력합니다.

### 개인적 풀이
&nbsp;이 문제에서 문자열의 길이가 계속 중복이 돼서 계산이 된다. 따라서 최대한 짧은 문자열을 많이 중복시키고 긴 문자열을 최소한으로 중복 시키면 된다. 따라서 매번 순회할 때 마다 가장 작은 문자열 2개를 찾아서 합치고 다시 배열에 넣고 이 과정을 배열의 길이가 1일 될때까지 반복하면 될 것 같다.

```c++
vector<int> strList;
int minCost, firstMinValue, secondMinValue;

int checkCost() {
	while(strList != 1) {
		minValue = findMinValue(*strList) + findMinValue(*strList);
		minCost += minValue;
		strList.push_back(minValue);
	}
	return minCost;
}
```

## 05. 풀이: 문자열 합치기

### 그림으로 그려보기
&nbsp;이 문제에 대한 직관을 얻는 좋은 방법은 문자열을 합치는 과정을 그림으로 그려보는 것이다.

### 탐욕적 알고리즘의 구상
&nbsp;문자열을 병합할 때마다 병합되는 문자열들의 총 길이가 전체 비용에 더해진다. 이렇게 각 비용을 분해해 보면 한 문자열로 인해 발생하는 총 비용은 이 문자열이 병합되는 횟수에 문자열의 길이를 곱한 것이다. 따라서 문자열이 길면 길수록 트리의 윗부분에 가깝고, 짧으면 짧을수록 아래쪽으로 내려가야 한다는 직관을 얻을 수 있다.

### 알고리즘 설계하기
&nbsp;항상 가장 짧은 두 개의 문자열을 합치는 것이 어떨까 하는 생각을 할 수 있다.

### 구현

```c++
// 문자열들의 길이가 주어질 때 하나로 합치는 최소 비용을 반환한다.
int concat(const vector<int>& lengths) {
	// 최소 큐를 선언한다
	priority_queue<int, vector<int>, greater<int> > pq;
	for(int i = 0; i < lengths.size(); ++i)
		pq.push(lengths[i]);

	int ret = 0;
	// 원소가 1개 이상 남은 동안 반복한다
	while(pq.size() > 1) {
		// 가장 짧은 문자열 두 개를 찾아서 합치고 큐에 넣는다
		int min1 = pq.top(); pq.pop();
		int min2 = pq.top(); pq.pop();
		pq.push(min1 + min2);
		ret += min1 + min2;
	}
	return ret;
}
```

### 이론적 배경: 허프만 코드
&nbsp;이 문제는 사실 탐욕적 알고리즘의 유명한 예인 허프만 코드 알고리즘을 각색한 것이다.