13장 수치 해석
====================================

## 01. 도입
#### &nbsp;수치 해석(numerical analysis)은 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 이들을 수치적 안정성, 오차의 범위 등을 연구하는 전산학의 한 분야로 다양한 범위에 널리 사용된다.

## 02. 이분법
#### &nbsp;가장 유용하게 사용되는 수치 해석 기법은 이분법(bisection method)이다.

* ### 이분법의 정의
#### &nbsp;이분법은 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법이다. 단조 함수가 아니고, 답이 여러 개 있는 함수라도 연속이기만 하면 이분법을 사용해 근을 찾을 수 있다. 이분법을 사용하기 위해서 함수의 그래프 상에서 x축 윗부분에 위치한 점 하나와 아랫부분에 위치한 점 하나를 찾아야 한다. 이런 후보의 중간 지점을 검사한다. 이런 과정을 통해 계속 절반으로 줄여 나가며 답을 찾는다.
```c++
double f(double x);
// 이분법의 예제 구현
double bisection(double lo, double hi) {
	// 반복문 불변식을 강제한다.
	if(f(lo) > 0)
		swap(lo, hi);
	// 반복문 불변식: f(lo) <= 0 < f(hi)
	while(fabs(hi - lo) > 2e-7) {
		double mid = (lo + hi) / 2;
		double fmid = f(mid);
		if(fmid <= 0)
			lo = mid;
		else
			hi = mid;
	}
	// 가운데 값을 반환한다
		return (lo + hi) / 2;
}
```

* ### 절대 오차를 이용한 종료 판정
#### &nbsp;이분법에서 가장 중요한 부분은 바로 while문의 종료 조건이다. 정확도와 수행 속도 사이에서 적절히 타협하는 종료 조건을 선택해야 한다. 문제의 정답이 10^-7이하의 차이가 나는 답들을 정답으로 인정할 때 fabs(hi - lo) > 2e-7와 같은 비교문을 while 조건문으로 넣는다. 반복문 불변식을 강제하기 위해 lo > hi가 될 수도 있기 때문에 항상 hi - lo의 절대 값을 취해야 한다.

* ### 상대 오차를 이용한 종료 판정
#### &nbsp;값의 크기가 커지면 문제가 생길 수 있다.

* ### 정해진 횟수만큼 반복하기
#### &nbsp;가장 유용한 방법은 while문을 적당한 for문으로 대체해서 반복문이 항상 정해진 횟수만큼 실행되도록 하는 것이다. 100번 정도만 실행해도 hi - lo가 10^20미만의 수라면 이 오차는 항상 10^-7보다 작다.

* ### 예제: 다변수 다항 방정식의 수치적 해법(문제 ID: ROOTS, 난이도: 중)
#### &nbsp;다변수 다항 방정식이랑 ax^2 + bx + c = 0 처럼 변수 하나만을 갖는 다항 방정식을 뜻한다. 5차 이상의 방정식은 아예 근의 공식이 없다. 어디까지나 이분법의 예제로만 받아들이고, 실제로는 수치 해석 알고리즘을 이용해야 한다. 다항식의 두 극점 사이에는 최대 하나의 근만이 있다. 따라서 극점들의 위치를 알아낼 수 있다면 그 사이에서 이분법을 이용해 근을 찾을 수 있을 것이다. 

* ### 예제: 전세금 균등상환(문제 ID: LOAN, 난이도: 하)
#### &nbsp;M개월 걸려 모든 대출 금액을 다 갚기 위해서는 한 달에 최소 얼마씩 갚아야 하는가.
```c++
// amount원을 연 이율 rates퍼센트로 duration월 간 한 달에 monthlyPayment로 남았을 때 대출 잔금은?
double balance(double amount, int duration, double rates,
	double monthlyPayment) {
	double balance = amount;
	for (int i = 0; i < duration; i++) {
		//이자가 붙는다.
		balance *= (1.0 + (rates / 12.0) / 100.0);
		//상환액을 잔금에서 제한다.
		balance -= monthlyPayment;
	}
	return balance;
}
// amount원을 연 이율 rates퍼센트로 duration월 간 갚으려면 한 달에 얼마씩 갚아야 하나?
double payment(double amount, int duration, double rates) {
	// 불변 조건:
	//1. lo원씩 갚으면 duration개월 안에 갚을 수 없다.
	//2. hi원씩 갚으면 duration개월 안에 갚을 수 있다.
	double lo = 0, hi = amount * (1.0 + (rates / 12.0) / 100.0);
	for (int iter = 0; iter < 100; iter++) {
		double mid = (lo + hi) / 2.0;
		if (balance(amount, duration, rates, mid) <= 0)
			hi = mid;
		else
			lo = mid;
	}
	return hi;
}
```

## 03. 문제: 승률 올리기 (문제ID: RATIO, 난이도: 하)
#### &nbsp;마이티 카드 게임 프로그램에서는 각 플레이어의 게임 횟수 G와 승리 횟수 W, 그리고 승률 R을 표시해 줍니다. 이때 R은 승리 확률을 백분울로 표시하되, 정수부만 표시한다. 예를 들어 64.8648...%이면 64%로 표시된다. 도경이는 N게임을 해서 M게임을 승리했다. 이제 표시되는 승리 확률이 1%만 더 올라가면 칭호를 획득하게 된다. 칭호를 흭득하기 위해서는 최소 몇 게임을 해야 하는가?

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 10초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (<= 100) 가 주어집니다. 그 후 C줄에 하나씩 각 테스트 케이스로 N과 M(1 <= N <= 10^9, 0 <= M <= N)이 주어진다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 도경이가 해야 할 최소 게임 수를 출력한다. 만약 20억 게임 내에 칭호를 획득할 수 없으면 -1을 출력한다.

* ### 개인적 풀이
#### &nbsp;직접 세어볼 수 없고, 지금 까지의 승률을 계산해 1%올린 승률에서 뺀 수를 저장한다. 이분법으로 승률을 n제곱 했을 때 이 수보다 크고 한번더 곱하면 작아지는 n을 구한다.

## 04. 풀이: 승률 올리기

* ### 직접 세어볼 수는 없다
#### &nbsp;이 문제를 푸는 방법은 게임을 하나씩 이겨나간다고 가정하고 승률이 변화하는 최초의 시점을 찾는 것이다. 따라서 이분법으로 풀어야 한다.

```c++
// 도경이가 할 생각이 있는 최대 게임 수
long long L = 2000000000;
// b게임 중 a게임 승리했을 때의 승률
int ratio(long long b, long long a) {
	return (a * 100) / b;
}
// 최소 몇 연승해야 승률이 올라갈까?
int neededGames(long long games, long long won) {
	// 불가능한 경우를 미리 걸러낸다
	if(ratio(games, won) == ratio(games + L, won + L))
		return -1;
	long long lo = 0, hi = L;
	// 반복문 불변식: 
	// 1. lo 게임 이기면 승률은 변하지 않는다
	// 2. hi 게임 이기면 승률은 변한다
	while(lo + 1 < hi) {
		long long mid = (lo + hi) / 2;
		if(ratio(games, won) == ratio(games + mid, won + mid))
			lo = mid;
		else
			hi = mid;
	}
	return hi;
}
```

* ### 수학적 해법
#### &nbsp;상수 시간에 동작하는 해법도 찾을 수 있다. N게임 중 M게임을 승리했고, 승률 R이 되고 싶다고 한다. 승률 R이 되는 최소의 연승 수 x를 구한다. x >= (RN - 100M) / (100 - R)

## 05. 삼분 검색

* ### 라면 끓이기
#### &nbsp;유니모달 함수(Unimodal function)의 최대점을 찾을 때 유용하게 사용할 수 있는 기법으로 삼분 검색(ternary search)가 있다.

* ### 삼분 검색
#### &nbsp;세 부분으로 나눠서 값을 비교해 극점을 찾는다.

* ### 왜 삼분 검색을 쓰나?
#### &nbsp;삼분 검색은 국소 탐색에 비해 훨씬 빠르고, 미분할 수 없는 함수에도 사용할 수 있다.

* ### 볼록 함수와 오목 함수
#### &nbsp;볼록 함수의 최소치를 구하거나 오목 함수의 최대치를 구하는 작업은 삼분 검색으로 쉽게 풀 수 있다. 볼록 오목 함수에서 수평선이 있을 수 있는 곳은 최소 최대 점 뿐이다.

* ### 삼분 검색으로 문제 해결하기
#### &nbsp;볼록 오목 함수에 관한 성질들을 이용하면 other(r) - cheaters(r)의 최대치도 쉽게 찾을 수 있다. 삼분법으로 계산한다.

## 08. 다른 주제들
#### &nbsp;수치 해석 알고리즘을 유용하게 사용할 수 있다.