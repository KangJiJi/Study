12장 최적화 문제 결정 문제로 바꿔 풀기
====================================

## 01. 도입
#### &nbsp;딱히 이름이 붙어 있지 않지만 굉장히 유용한 디자인 원칙 중 하나로, 최적화 문제를 결정 문제(Decision problem)으로 바꾼 뒤, 이것을 이분법을 이용해 해결하는 방법이 있다. 결정 문제란 예 혹은 아니오 형태의 답만 나오는 문제들을 가리킨다.

* ### 최적화 문제와 결정 문제의 관계
#### &nbsp;결정 문제가 최적화 문제보다 어려울 수는 없다. decision()이 optimize()보다 시간 복잡도가 클 일은 결코 없다.

* ### 예제: DARPA Grand Challenge(문제 ID: DARPA, 난이도: 중)
#### &nbsp;DARPA Grand Challenge 는 운전자 없는 차들을 컴퓨터 인공지능으로 조작해 누가 먼저 결승점에 도달하느냐를 가지고 겨루는 인공지능 대회입니다. 2004년 DARPA Grand Challenge 의 과제는 사막을 가로지르는 240km 도로를 완주하는 것이었습니다. 우리는 이 경기를 N 개의 카메라로 중계하려고 합니다. 이 도로에는 카메라를 설치할 수 있는 곳이 M 군데 있습니다. 여기에 카메라를 배치하여, 가장 가까운 두 카메라 간의 간격을 최대화하고 싶습니다. 이와 같은 배치를 찾아내는 프로그램을 작성하세요.

* ### 최적화 문제와 결정 문제
#### &nbsp;결정 문제로 변환을 해서 함수의 형태로 표현하면 다음과 같다. decision(locations, cameras, gap) = 카메라를 설치할 수 있는 위치 locations와 카메라의 수 cameras가 주어질 때, 이들을 적절히 배치해 모든 카메라의 간격이 gap이상이 되도록 하는 방법이 있는가?

* ### 어떤 질문을 할 것인가?
#### &nbsp;decision()이 대답하는 질문이 "카메라들 간의 최소 간격이 gap이상인 방법이 있는가?"인 것에 유의해야한다. "답 x가 존재하는가?" 라는 질문 대신에 "x 또는 그보다 좋은 답이 있는가?"라는 질문에 대답한다. 이러한 형태의 질문을 이용해 최적화 문제를 푸는 쉬운 방법이 있다. 이분법 알고리즘을 이용해 답을 찾을 수 있다.

* ### 결정 문제 풀기
```c++
// 결정 문제 : 정렬되어 있는 locations 중 cameras를 선택해 모든 카메라 간의 간격이 
// gap 이상이 되는 방법이 있는지를 반환한다.
bool decision (const vector<double>& location, int cameras, double gap) {
  // 카메라를 설치할 수 있을 때마다 설치하는 탐욕적 알고리즘 
  double limit = -1;
  int installed = 0 ;
  for (int i = 0; i < location.size(); i++) {
    if (limit <= location[i]) {
      ++installed;
      // location[i] + gap 이후는 되어야 카메라를 설치할 수 있다.
      limit = location[i] + gap;
      }
  }
  // 결과적으로 cameras대 이상을 설치할 수 있었으면 성공 
  return installed >= cameras;
}

// 최적화 문제 : 정렬되어 있는 locations 중 cameras를 선택해 최소 간격을 최대화한다.
double optimize (const vector<douoble>& location, int cameras) {
  double lo = 0; hi = 241;
  // 반복문 불변식 : decision(lo) && !decision(hi)
  for (int it = 0; it < 100; it++) {
    double mid = (lo + hi) / 2.0;
    // 간격이 mid 이상이 되도록 할 수 있으면 답은 [mid,hi]에 있다.
    if (decision(location,cameras,mid))
      lo = mid;
    // 간격이 mid 이상이 되도록 할 수 없으면 답은 [lo,mid]에 있다.
    else 
      hi = mid;
  }
  return lo;
}
```

* ### 이분법의 함정
#### &nbsp;이 문제에서 답이 가질 수 있는 값의 가지수는 사실 유한하다. 탐색의 범위가 유한해지면 이분법은 수치적 안정성을 잃어버리게 된다.

* ### 다른 해법
#### &nbsp;m개의 위치 중 n개를 선택해 카메라를 선택하는 문제를 n조각으로 쪼개, 각 조각마다 어느 위치에 카메라를 설치할지 정한다고 한다. 이 문제는 사실 동적 계획법으로도 풀 수 있다.

* ### 최적화 문제 결정 문제로 바꾸기 레시피
#### &nbsp;"가장 좋은 답은 무엇인가?" 라는 최적화 문제를 "x 혹은 그보다 좋은 답이 있는가?" 라는 결정 문제 형태로 바꾼다. 결정 문제를 쉽게 풀 수 있는 방법이 있는지 찾아본다. 결정 문제를 내부적으로 이용하는 이분법 알고리즘을 작성한다.

## 02. 문제: 남극 기지(문제 ID: ARCTIC, 난이도: 하)
#### &nbsp;남극에는 N 개의 탐사 기지가 있습니다. 남극의 겨울은 혹독하기 때문에, 남극의 겨울이 찾아오면 탐사 기지들간의 왕래가 중단됩니다. 겨울에도 서로 통신하며 연구를 지속하기 위해, N 개의 무전기를 구입해 각 탐사 기지에 배치하려 합니다. 이 때, 두 탐사 기지 사이의 거리가 D 라고 하면, 무전기의 출력이 D 이상이어야만 통신이 가능합니다. 모든 탐사 기지에는 똑같은 무전기가 지급됩니다. 탐사 본부가 다른 모든 기지에 연락을 할 수 있기 위해 필요한 무전기의 최소 출력은 얼마일까요? 탐사 본부는 다른 기지를 통해 간접적으로 연락할 수 있다고 가정합니다.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 기지의 수 N (<= 100)이 주어지고, 그 다음 줄에 2개씩의 실수로 각 기지의 좌표 (x,y) 가 주어집니다. 기지의 위치는 0 이상 1000 이하의 실수입니다. 이 때 첫 번째 주어지는 기지가 탐사 본부라고 가정합니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다, 탐사 본부가 다른 모든 기지에 연락을 할 수 있기 위해 필요한 최소 무전기의 출력을 소숫점 밑 셋째 자리에서 반올림해 출력합니다.

## 03. 풀이: 남극 기지
#### &nbsp;optimize(P) = P에 주어진 기지들을 모두 연결하는 연락망을 구축할 때 간으한 최소 무전기 반경은 얼마인가? 이러한 최적화 문제를 결정 문제 형태로 바꾼다. decision(P, d) = 모든 기지를 하나로 연결하되, 가장 먼 두 기지 간의 거리가 d이하인 연락망이 있는가?
```c++
int C, N;
// 두 기지 사이의 거리를 미리 계산해둔다.
double dist[100][100];
// 거리가 d 이하인 기지들만을 연결했을 때 모든 기지가 연결되는지 여부를 반환한다.
bool decision(double d) {
	vector<bool> visited(N, false);
	visited[0] = true;
	queue<int> q;
	q.push(0);
	int seen = 0;
	while (!q.empty()) {
		int here = q.front();
		q.pop();
		seen++;
		for (int there = 0; there < N; there++) {
			if (!visited[there] && dist[here][there] <= d) {
				visited[there] = true;
				q.push(there);
			}
		}
		return seen == N;
	}
}

//모든 기지를 연결할 수 있는 최소의 d를 반환한다.
double optimize() {
	double lo = 0, hi = 1416.00;
	for (int it = 0; it < 100; it++) {
		double mid = (lo + hi) / 2;
		//mid가 가능하다면, 더 좋은 (작은) 답을 찾는다.
		if (decision(mid))
			hi = mid;
		//mid가 불가능하다면, 더 나쁜 (큰) 답을 찾는다.
		else
			lo = mid;
	}
	return hi;
}
```

* ### 다른 해법
#### &nbsp;크루스칼의 최소 스패닝 트리 혹은 플로이드의 모든 쌍 최단 거리 알고리즘 등을 간단히 변형하면 풀 수 있다.

## 04. 문제: 캐나다 여행(문제 ID: CANADATRIP, 난이도: 중)
#### &nbsp;동건이는 여름 방학을 맞아 자동차를 끌고 캐나다 횡단 여행을 떠나기로 했습니다. 캐나다의 1번 고속도로는 세계에서 가장 긴 고속도로 중 하나로, 캐나다의 동쪽 끝에서 서쪽 끝까지 있는 모든 주요 도시를 연결합니다. 동건이는 이 고속도로를 타고 캐나다의 서쪽 끝 빅토리아에서 동쪽 끝 세인트 존까지 8,030km 를 달리기로 마음먹었습니다. 이 고속도로는 굉장히 많은 표지판이 있기로도 유명합니다(이 문장부터는 사실이 아닙니다..). 이 고속도로는 N개의 주요 도시를 지나치는데, 각 도시까지의 남은 거리를 나타내는 표지판이 많기 때문입니다. i번째 도시까지의 거리를 나타내는 표지판은 도시에 도착하기 Mi미터 전부터 시작해서 도시에 도착할 때까지 Gi미터 간격으로 설치되어 있습니다. 예를 들어 M0=500이고 G0=50이라고 하면 여행자는 다음과 같은 11개의 표지판을 순서대로 보게 됩니다. 시작점으로부터 각 도시까지의 거리 Li와 Mi, Gi가 주어질 때, 시작점으로부터 여행하면서 동건이가 보게 되는 K번째 표지판의 위치를 계산하는 프로그램을 작성하세요. 한 위치에 표지판이 여러 개 있을 경우에도 각각의 표지판을 따로 세기로 합니다.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 T (T <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 도시의 수 N (1 <= N <= 5000) 과 K (1 <= K <= 2^31-1) 가 주어집니다. 그 후 N줄에는 각 3개의 정수로 Li, Mi, Gi (1 <= Gi <= Mi <= Li <= 8,030,000) 가 주어집니다. Mi는 항상 Gi의 배수입니다. K는 항상 총 표지판의 수 이하입니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 한 줄에 K번째 표지판의 위치를 출력합니다.

## 05. 풀이: 캐나다 여행
#### &nbsp;입력에 주어지는 K의 범위를 보더라도 '단순한' 알고리즘으로 이용할 수는 없다. decision(x) = 시작점부터 x미터 지점까지 가면서 K개 이상의 표지판을 만날 수 있는가? decision(X - 1) = false, decision(X) = ture인 부분을 이분법으로 간단하게 구현해서 찾을 수 있다.

* ### decision() 구현하기
```c++
int n, k;
int l[5000], m[5000], g[5000];
// 결정 문제: dist 지점까지 가면서 k 개 이상의 표지판을 만날 수 있는가?
bool decision(int dist) {
	int ret = 0;
	for(int i = 0; i < n; i++)
		// i 번째 도시 표지판을 하나 이상 보게 되는가?
		if(dist >= l[i] - m[i])
			ret += (min(dist, l[i]) - (l[i] - m[i])) / g[i] + 1;
	return ret >= k;
}
// k번째 표지판을 만나는 지점의 위치를 계산한다
int optimize() {
	// 반복문 불변 조건: !decision(lo) && decision(hi)
	int lo = -1, hi = 8030001;
	while(lo+1 < hi) {
		int mid = (lo + hi) / 2;
		if(decision(mid))
			hi = mid;
		else
			lo = mid;
	}
	return hi;
}
```