# CHAPTER 1 스코프란 무엇인가

&nbsp;특정 장소에 변수를 저장하고, 그 변수를 잘 찾는데 정의된 규칙을 '스코프(Scope)'라 한다.

## 1. 컴파일러 이론

&nbsp;자바스크립트는 사실은 '컴파일러 언어'다. 하지만 다른 전통적인 컴파일러 언어의 특징을 가지고 있지는 않다. 그러나 자바스크립트 엔진은 전통적인 컴파일러가 하는 일의 상당 부분을 세련된 방식으로 처리한다. 전통적인 컴파일러 언어는 '컴파일레이션(Compilation)'이라는 3단계를 거쳐서 소스코드를 실행한다. 3단계는 다음과 같다.

- 토크나이징(Tokenizing) / 렉싱(Lexing)
- 파싱(Parsing)
- 코드 생성(Code-Generation)

### 토크나이징(Tokenizing) / 렉싱(Lexing)

&nbsp;문자열을 '토큰(Token)'이라는 의미 있는 조각으로 나누는 과정이다. `var a = 2;`는 다음과 같이 분리 된다.

- `var`
- `a`
- `=`
- `2`
- `;`

### 파싱(Parsing)

&nbsp;토큰 배열을 AST(Abstract Syntax Tree, 추상 구문 트리)로 바꾸는 과정이다. `var a = 2;`는 다음과 같은 트리로 만들어진다.

- 변수 선언(Variable Declaration)이라는 최상위 노드
- 최상위 노드는 'a'의 값을 가지는 확인자(Identifier)와 대입 수식(Assignment Expression)이라는 두개의 자식 노드를 가진다.
- 대입 수식 노드는 '2'라는 값을 가지는 숫자 리터럴(Numeric Literal)을 자식노드로 가진다.

### 코드 생성(Code-Generation)

&nbsp;AST를 실행 코드로 바꾸는 과정이다. AST를 기계어 집합으로 바꾸는 과정이다.

## 2. 스코프 이해하기

&nbsp;스코프를 대화 형식으로 살펴본다.

### 출연진

&nbsp;`var a = 2;`를 처리하는 과정이다.

- 엔진: 자바스크립트 프로그램 전 과정의 실행을 책임진다.
- 컴파일러: 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
- 스코프: 선언된 모든 확인자(변수)검색 목록을 작성하고 유지한다. 또한, 현재 실행 코드에서 확인자 적용 방식을 정한다.

### 앞과 뒤

&nbsp;`var a = 2;`는 컴파일러가 컴파일레이션 과정에서 처리하는 구문과 실행 과정에서 엔진이 처리할 구문으로 나누어 진다. 컴파일러는 다음과 같은 일을 진행한다.

- 컴파일러가 `var a`를 만나면 스코프에게 변수 a가 스코프 컬렉션 안에 있는지 묻는다. 변수가 있다면 선언을 무시하고, 없다면 새로운 변수 a를 생성한다.
- 그 후 `a = 2`대입문 처리를 위해 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 a에 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 다른 곳을 살핀다.

엔진이 변수를 찾으면 변수에 2를 넣고, 못 찾는다면 에러를 발생시킨다.

### 컴파일러체

&nbsp;엔진이 하는 검색은 LHS(Left-Hand Side)와 RHS(Right-Hand Side)가 있다. 변수가 대입 연산자 왼쪽에 있으면 LHS, 오른쪽에 있으면(왼편이 아닌 쪽) RHS를 수행한다.

```javascript
console.log(a);
```

위 코드에서 a에 대한 참조는 RHS 참조다. a에 값을 대입하지 않기 때문이다.

```javascript
a = 2;
```

a에 대한 참조는 LHS 참조다. 대입 연산을 수행할 대상 변수를 찾기 때문이다. 다음은 LHS와 RHS참조를 모두 수행하는 코드다.

```javascript
function foo(a) {
  console.log(a); // 2
}
foo(2);
```

`foo()`에 인자값으로 2를 넘겨줄 때 `a = 2`를 실행한다. 이때 LHS참조가 수행된다. 또한 `console`객체를 RHS검색하여 `log`메서드가 있는지 확인한다. 또한 `log()`에도 LHS참조를 통해 인자 값을 넘겨준다.

### 엔진과 스코프의 대화

```javascript
function foo(a) {
  console.log(a);
}
foo(2);
```

## 3. 중첩 스코프

&nbsp;스코프도 다른 스코프안에 중첩(Nested)될 수 있다. 변수를 현재 스코프에서 발견하지 못하면 글로벌 스코프에 도달할 때 까지 계속 검색을 하게 된다.

```javascript
function foo(a) {
  console.log(a + b);
}
var b = 2;
foo(2); // 4
```

중첩 스코프 탐사는 다음과 같은 규칙이 있다.

- 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
- 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

### 비유로 배워보기

&nbsp;빌딩에 비유해 각 층을 돌아다니면서 LHS, RHS 참조하면서 층을 둘러보고, 찾기 못하면 다음층으로 가서 찾고, 또 다음 층으로 이동하는 식이다. 옥상까지 가게되면 무조건 탐색을 중단한다.

## 4. 오류

&nbsp;RHS와 LHS는 변수가 아직 선언되지 않았을 때 다르게 동작한다.

```javascript
function foo(a) {
  console.log(a + b);
  b = a;
}
foo(2);
```

`b`에 대한 첫 RHS 검색이 실패하면 `ReferenceError`를 발생시킨다. 하지만 LHS 검색을 수행하면 글로벌 스코프에 새로운 변수를 만들어 넘겨준다. 단 'Strict Mode'에서는 안된다.

## 5. 정리하기

&nbsp;스코프는 변수를 찾는것에 대한 규칙의 집합이다. 변수를 찾아서 대입을 하거나(LHS참조) 변수의 값을 얻어올 수 있다(RHS참조). LHS와 RHS참조 검색은 현재 스코프에서 시작해 글로벌 스코프까지 이동한다. RHS 참조가 대상을 못찾으면 `ReferenceError`, LHS 참조가 대상을 못찾으면 암시적으로 글로벌 스코프에 변수가 생성된다('Strict mode'가 아닐때).
