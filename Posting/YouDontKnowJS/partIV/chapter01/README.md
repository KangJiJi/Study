# CHAPTER 1 비동기성: 지금과 나중

&nbsp;일정 시간 동안 발생하는 프로그램의 움직임을 어떻게 표현하고 나타낼 것인가? 지금과 나중의 간극에 관한 문제다. 사용자 입력 대기, DB 정보 조회, 네트워크 요청같은 것들이 여기에 해당된다. 프로그램에서 이러한 간극이 비동기 프로그램의 핵심이다.

## 1. 프로그램 덩이

&nbsp;JS 프로그램은 보통 '지금' 실행 중인 프로그램 덩이 하나와 '나중'에 실행할 프로그램의 덩이로 구성된다. 이때 덩이의 단위는 함수다. '나중'은 '지금'의 직후가 아니다. '지금'당장 끝낼 수 없는 작업은 프로그램을 Blocking 하지 않는다.

```javascript
var data = ajax('http://some.url.1');

console.log(data); // 출력안됨
```

위에서 볼 수 있듯이 `ajax`는 비동기로 동작한다. '지금' 요청하고 '나중'에 결과를 받는다. 이런경우 '지금'부터 '나중'까지 기다리는 간단한 방법은 콜백 함수를 이용하는 것이다.

```javascript
ajax('http://some.url.1', function myCallbackFunction(data) {
  console.log(data);
});
```

### 비동기 콘솔

&nbsp;console.\* 메서드는 브라우저와 JS 실행환경에 따라 작동 방식이 다르다. 특히 `console.log()` 메서드는 브라우저가 I/O 를 성능을 위해서 백그라운드에서 비동기적으로 처리하기 때문에 가끔 결과가 다른게 출력되기도 한다. 따라서 중단점을 활용하는 것이 최선이다.

## 2. 이벤트 루프

&nbsp;JS 에는 비동기란 개념은 없다. JS 엔진은 누군가 요청하면 프로그램을 한 덩이씩 실행할 뿐이다. JS 엔진은 반드시 호스팅 환경(Runtime)에서 실행된다. 여러 환경에서도 Thread는 공통이다. 여러 프로그램 덩이를 시간에 따라 엔진을 실행시키는 이벤트 루프라는 장치다. 정리하자면 JS 엔진은 JS 코드 덩이를 주는 대로 처리하는 실행기일 뿐, 이벤트 스케줄링은 엔진을 감싸고 있는 호스팅 환경의 몫이다. 이벤트 루프의 의사 코드는다음과 같다.

```javascript
// eventLoop is queue
var eventLoop = [];
var event;

while (true) {
  // '틱' 발생
  if (eventLoop.length > 0) {
    // Queue에 있는 다음 이벤트 조회
    event = eventLoop.shift(); // 이벤트 실행
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

`while문`의 매 순회를 틱이라 하고, 틱이 발생할 때마다 큐에 적재된 이벤트를 꺼내서 실행한다. 이때 주의할 점은 `setTimeout()`은 콜백을 이벤트 루프 큐에 넣지 않는다는 것이다. `setTimeout()`은 타이머를 설정할 뿐이고 타이머가  끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 JS 엔진이 콜백을 꺼내서 실행시킨다. 이벤트 루프가 많은 이벤트로 가득 차 있으면 맨 끝에서 대기한다. `setTimeout()` 타이머가 항상 완벽하게 정확하지 않은 이유가 이 때문이다.

> ES6 부터는 이벤트 루프 큐 관리 방식이 호스팅 환경이 아닌 JS 엔진의 관할이 됐다.

## 3. 병렬 스레딩

&nbsp;비동기와 병렬은 완전히 다르다. 비동기는 '지금'과 '나중' 사이의 간극에 관한 용어고 병렬은 동시에 일어나는 일들로 연관된다. Process와 Thread는 병렬 컴퓨팅 도구로, Processor는 독립적으로 실행되며 여러 Thread는 하나의 프로세스 메모리를 공유한다. 반면 이벤트 루프는 공유 메모리에 병렬로 접근하거나 변경할 수 없다. 병렬성과 직렬성이 나뉜 Thread에서 이벤트 루프를 협동하는 형태로 공존한다. 이때 병렬 실행 스레드 Interleaving과 비동기 이벤트 Interleaving은 완전히 다른 수준의 단위에서 일어난다. 단일 스레드 환경에서는 스레드 간섭이 일어나지 않으므로 저수준 작업(함수의 내용)이 쌓여 있어도 별문제 없다. 하지만 병렬 시스템에서는 예상치 못한 일들이 발생한다.

```javascript
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

JS는 단일 스레드로 동작하니까 `a`는 `42` 혹은 `41`의 값이 된다. 하지만 같은 데이터를 공유하는 병렬 실행 문제는 더 복잡하다. `foo`와 `bar`가 각각의 스레드로 메모리 공간을 차지하면 `a`값을 각각 읽어 들여서 `44`, `21`과 같은 이상한 값이 나오게 된다. 이래서 스레드 프로그래밍이 어렵다. JS 는 스레드 간 데이터를 공유하지 않아서 위와 같은 비결정성(Nondeterminism) 문제는 없다. 그렇다고 항상 결정적(Deterministic)이란 소리도 아니다. 위에서 봤듯이 싱글 스레드에서도 `41`, `42` 두 값중 하나가 나왔다.

### 완전-실행

&nbsp;단일 스레드에서 `foo()` 내부의 코드는 원자적(atomic)이다. 일단 `foo()`가 실행이 끝나고 `bar()`함수를 실행한다. 이를 완전-실행(Run to completion)이라 한다. 위 코드에서 `foo()`와 `bar()`는 `ajax`요청이 먼저 끝나는 순서(Either first order)대로 실행된다. 똑같은 코드인데 결과는 두 가지이기 때문에 비결정적이다. 하지만 여기서 비결정성은 함수의 순서에 따른 것이지, 문의 순서(표현식의 처리 순서) 수준까지는 아니다. 따라서 스레드 보다는 결정적이라고 할 수 있다. 이런 함수 순서에 따른 비결정성을 경합 조건(Race condition)이라고 한다.

> 제너레이터는 함수가 완전-실행되지 않는다.

## 4. 동시성

&nbsp;사용자가 스크롤바를 아래로 내리면 계속 생신된 상태 리스트가 화면에 표시되는 웹 페이지를 만들고자 한다. 이런 기능은 2개의 분리된 프로세스(OS수준의 프로세스가 아닌 작업)를 동시에 실행할 수 있어야 제대로 기능을 구현할 수 있다. 첫 번째 프로세스는 `onscroll`이벤트에 반응하고, 두 번째 프로세스는 `ajax`응답을 받는다. `ajax`응답을 기다리는 중 스크롤을 내리면 두 이벤트가 인터리빙 된다. 동시성은 복수의 프로세스가 동시에 실행됨을 의미하며, 작업이 병렬로 처리되는지와는 관계없다. 따라서 동시성은 프로세스(작업) 수준의 병행성이라 할 수 있다. 다시 예제를 생각하면 '프로세스 1'과 '프로세스 2'는 동시에 실행되지만 이들을 구성하는 이벤트(함수의 내용)들은 이벤트 루프 큐에서 차례대로 실행된다.

### 비상호 작용

&nbsp;프로세스를 동시에 인터리빙 할 때 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호 작용은 사실 의미가 없다. 프로세스 간 상호작용이 일어나지 않는다면 비결정성은 완벽하게 수용 가능하다.

### 상호 작용

&nbsp;경합 조건을 해결하기 위해서 상호 작용 순서를 잘 조정해야 한다.

```javascript
var res = [];

function response(data) {
  if (data.url == 'http://some.url.1') {
    res[0] = data;
  } else if (data.url == 'http://some.url.2') {
    res[1] = data;
  }
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

위와 같이 간단한 방법으로 비결정성을 해소할 수 있다. 이러한 동시적 상호 작용 조건은 여럿있다. Gate나 Latch를 이용해서 코드로 해결할 수 있다.

### 협동

&nbsp;협동적 동시성(Cooperative Concurrency)역시 동시성을 조정하는 다른 방안이다. 실행 시간이 오래 걸리는 프로세스(작업)를 여러 단계로 쪼개어 다른 동시 프로세스(작업)가 각자 작업을 이벤트 루프 큐에 인터리빙 하도록 하는 게 목표다. 예를 들어 긴 리스트를 받아 값을 변환하는 `ajax`응답 처리기가 있다고 하자.

```javascript
var res = [];

function response(data) {
  res = res.concat(
    data.map(function (val) {
      return val * 2;
    })
  );
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

위 코드에서 응답 데이터가 매우 길면 처리 시간이 제법 걸린다. 그러면 페이지는 멈추고, 사용자 이벤트도 먹통이 된다. 따라서 이벤트 루프 큐를 독점하지 않도록 각 결과를 비동기 배치로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행되게끔 해야 한다.

```javascript
var res = [];

function response(data) {
  var chunk = data.splice(0, 1000);
  res = res.concat(
    chunk.map(function(val) {
      return val * 2;
    })
  };

  if(data.length > 0) {
    // setTimeout(..., 0)은 스케줄링 꼼수로 '이 함수를 현재 이벤트 루프 큐의 맨 뒤에 붙여주세요' 라는 의미를 가진다.
    setTimeout(function(){
      response(data);
    }, 0);
  }
}

ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

1,000개 원소를 가진 덩이 단위로 데이터 집합을 처리했다. 이렇게 하면 각 프로세스(작업)처리 시간은 단축되므로 이벤트 루프 큐에 인터리빙이 가능하고 응답성 좋은 사이트를 만들 수 있다. 하지만 순서가 중요한 경우는 이렇게 하면 안되고 콜백을 이용해야 한다.

## 5. 잡

&nbsp;잡 큐(Job Queue)는 ES6부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 잡 큐는 '매 틱의 끝자락에 매달려 있는 큐'라고 생각할 수 있다. 잡은 처리 순서가 더 잘 정의돼 있고 순서가 보장된다.

## 6. 문 순서

&nbsp;JS 엔진은 반드시 문의 순서대로 실행하지 않는다. 보통 코드는 비동기적인 요소가 없으면 위에서 아래로 한 줄씩 실행될 것이다. 하지만 JS 엔진은 코드를 커파일 한 뒤, 문 순서를 재정렬하면서 실행 시간을 줄일 방법을 찾는다.

```javascript
// 우리가 작성한 코드
var a, b;

a = 10;
b = 10;

a = a + 1;
b = b + 1;

console.log(a + b);

// JS 엔진이 변경한 코드(어디까지나 예시)
var a, b;

a = 11;
b = 31;

console.log(a + b);
```

결과는 변하지 않는다. 하지만 '부수 효과가 있는 함수 호출', 'ES6 프록시 객체' 등 부수 효과 때문에 순서를 조정하면 안되는 코드도 있다. 기억할 점은 소스 코드 순서와 컴파일 후 실행 순서는 아무 관련이 없다는 사실이다.

## 7. 정리하기

- JS는 항상 2개 이상의 덩이로 쪼개지며 '지금'덩이와 '나중'덩이로 나눌 수 있다.
- 모든 덩이가 프로그램 상태에 접근할 수 있어서 상태의 변화는 차례대로 반영된다.
- JS 엔진은 이벤트 루프 큐를 실행 할 뿐이다. 이벤트 루프를 한 차례 순회하는 것을 틱이라 한다.
- 언제나 한 번에 한 개의 이벤트만 큐에서 꺼내 처리한다.
- 동시성은 복수의 이벤트들이 연쇄적으로 인터리빙 되면서 동시에 실행되는 것처럼 보인다.
- 동시 '프로세스'들은 실행 순서를 보장하거나 경합 조건을 예방하는 등의 조치를 해야한다.
- 동시 '프로세스'들을 더 작은 덩이라 잘게 나누어 다른 '프로세스'에 인터리빙 되게하는 협동이 가능한다.
