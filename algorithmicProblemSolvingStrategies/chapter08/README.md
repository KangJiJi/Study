8장 동적 계획법
==============

## 01. 도입
#### &nbsp;동적 계획법은 프로그래밍 대회 문제에서 가장 자주 출현하는 디자인 패러다임 중 하나이다. 동적 계획법(Dynamic programming)이라는 말은 최적화 문제를 연구하는 수학 이론에서 왔으면, 우리가 전산학 전반에서 일반적으로 사용하는 동적(dynamic), 혹은 프로그래밍(programming)이란 단어와는 아무런 관련이 없다. 따라서 dynamic programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법이다.

* ### 중복되는 부분 문제
#### &nbsp;동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있다. 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산 하고 계산 결과를 재활용함으로써 속도의 향상을 불러온다. 그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다. 나눠진 각 문제들이 같은 부분 문제에 의존을 할 때, 단순하게 재귀 호출을 동해 각 문제를 해결하면 중복 계산이 많아진다. 계산의 중복 횟수는 분할이 깊이가 깊어질 수록 지수적으로 증가하게 된다. 이 현상을 조합 폭발(combination explosion)이라고 부른다. 이런 문제를 해결하기 위해 고안된 알고리즘 설계 기법이 동적 계획법이다. 가장 유명한 예 중 하나는 이항 계수(binomial coefficient)의 계산이다. bino(n, r)을 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것으로 한다.
```c++
bino(n, r) = bino(n - 1, r - 1) + bino(n - 1, r);
```
#### 위와 같은 점화식이 성립한다.
```c++
int bino(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  return bino(n - 1, r - 1) + bino(n - 1, r);
}
```
#### 위 코드는 재귀 호출을 이용해서 bino를 구현한 것이다. 이때 계산하는 과정에서 많은 중복이 일어나며, 숫자가 커질수록 함수 호출 횟수는 기하 급수적으로 늘어난다. 따라서 cache 배열을 만들어서 각 입력에 대한 반환 값을 저장한다. 한번 계산한 값을 저장해 뒀다 재활용 하는 기법을 메모이제이션(memoization)이라고 부른다.
```c++
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
}
```
#### 이렇게 하면 함수 호출 횟수가 엄청나게 감소한다.

* ### 메모이제이션을 적용할 수 있는 경우
#### &nbsp;프로그래밍에서의 함수는 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수 많은 입력에 의해 작동하기 때문에 입력이 똑같다고 매번 출력이 같은 것은 아니다. 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들에만 적용할 수 있다.

* ### 메모이제이션 구현 패턴
```c++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### 위와 같은 함수를 다음과 같은 패턴으로 바꾼다.
```c++
// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아는 정수
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리한다.
  if(...) return ...;
  // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if(ret != -1) return ret;
  // 여기에서 답을 계산한다.
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache 배열을 초기화 시킨다
  memset(cache, -1, sizeof(cache));
}
```
#### 이런 일관적인 패턴은 디버깅을 도와준다.

* ### 메모이제이션의 시간 복잡도 분석
#### &nbsp;간단하게 다음과 같은 식을 이용해서 시간 복잡도를 계산할 수 있다.
```c++
(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```
#### 이 식은 항상 정확하지는 않지만 상한을 간단히 계산할 수 있는 방법이다.

* ### 예제: 외발 뛰기(문제 ID: JUMPGAME, 난이도: 하)
#### &nbsp;땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다. 균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다. 게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.

* ### 개인적 풀이
#### &nbsp;메모이제이션 기법을 사용하기 위해서 check[101][101]배열을 생성하고 각 좌표에서 출발해 본적이 있으면 1을 넣고 아니면 -1을 넣는다. 처음에 0, 0에서 시작하고 재귀적으로 갈수 있는 좌표 모두를 가본다. 이렇게 n, n에 도달 했는지를 검사한다.
```c++
int n;
int board[101][101];
int check[101][101];
checkBoard(int x, int y) {
  // 기저 사례 끝부분에 도착하면 2를 반환하고 접근할 수 없는 인덱스에 접근했을 때 -1을 반환
  if(x == n && y == n) return 2;
  if(x > n || y > n) return -1;

  // 특정 좌표에서 출발해 본적이 있는지 검사
  int ret = check[x][y];
  if(ret == 1) return ret;

  int& move = board[101][101];
  ret = checkBoard(x + move, y) || checkBoard(x, y + move);

  return ret;
}
```
#### 이런 방향성을 가지고 풀게 되면 될 것 같다.

* ### 재귀 호출에서 시작하기
#### &nbsp;동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 모든 경로를 하나씩 만들어 봄녀서 마지막 칸에 도달할 수 있는지를 검사한다.
```c++
int n, board[100][100];
bool jump(int y, int x) {
  // 기저 사례: 게임판 밖을 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n - 1 && x == n - 1) return true;
  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

* ### 메모이제이션 적용하기
#### &nbsp;완전 탐색을 사용할 때 흔히 가장 문제가 되는 것은 원하는 전체 답의 개수는 무지막지하게 많은 경우다. 다음은 메모이제이션을 적용해서 중복을 없애는 코드다.
```c++
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
  // 기저 사례
  if(y >= n || x >= n) return 0;
  if(y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if(ret != -1) return ret;
  int jumpSize = board[y][x];
  return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```

* ### 내가 짠 코드와 비교해 보기
#### &nbsp;아이디어는 똑같았지만 아직 언어에 대한 이해와 문법 능력이 부족해 오류가 나는 코드를 만들었다. 포인터와 언어에 대한 이해가 조금더 필요하다.


* ### 다른 해법
#### &nbsp;이 문제는 사실 크래프로 모델링해보면 아주 간단한 도달 가능성 문제가 된다.

* ### 동적 계획법 레시피
#### &nbsp;1. 주어진 문제를 완전 탐색을 이용해 해결한다. 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

* ### 다른 구현 방법에 관하여
#### &nbsp;재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현할 수 있다. 이런 방법을 반복적 동적 계획법이라고 부른다.

## 02. 문제: 와일드카드(문제 ID: WILDCARD, 난이도: 중)
#### &nbsp;와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다. 와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다. 예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다. 와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

* ### 개인적 풀이
#### &nbsp;이 문제에 대해서는 풀이법이 잘 떠오르지 않는다.

## 03. 풀이: 와일드카드

* ### *가 문제로다
#### &nbsp;이 문제를 어렵게 만드는 것은 *가 몇 글자에 대응되어야 하는지를 미리 알 수 없다는 점이다. 주어진 패턴이 m개의 *을 포함한다고 한다. 이 패턴을 *가 나타날 때마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌 수 있다. 예를 들어 t*l?*o*r?ng*s는 t*, l?*, o*, r?ng*, s로 나눌 수 있다. 이렇게 쪼갠 문자열이 대응되는지 여부를 재귀 호출로 파악할 수 있다. 물론 실제로 패턴을 쪼개지 않고도 이를 구현할 수 있다.
```c++
// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {
  // w[pos]와 s[pos]를 맞춰나간다.
  int pos = 0;
  while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos]))
    ++pos;
  // 더이상 대을할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨.
  if(pos == w.size())
    return pos == s.size();
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(w[pos] == '*')
    for(int skip = 0; pos + skip <= s.size(); ++skip)
      if(match(w.substr(pos + 1), s.substr(pos + skip)))
        return true;
  // 이 외의 경우에는 모두 대응되지 않는다.
  return false;
}
```

* ### 중복되는 부분 문제
#### &nbsp;위와 같은 방법은 *가 많을 수록 이 경우의 수는 늘어나서 오랜 시간이 걸린다. 예를 들어 123*abc*def*ghi이 패턴에는 '*'가 세 개 있는데 이때 def*ghi 부분이 123*...과 abc*...를 해결할 때 중복된다. 입력으로 주어질 수 있는 w와 s는 각각 최대 101개밖에 없다. 다음과 같이 메모이제이션을 사용해 중복 계산을 줄일 수 있다.
```c++
// -1은 아직 답이 계산되지 않았음을 의미한다.
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열
string W, S;
// 파일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s) {
  // 메모이제이션
  int& ret = cache[w][s];
  if(ret != -1) return ret;
  // W[w]와 S[s]를 맞춰나간다.
  while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
    ++w;
    ++s;
  }
  // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참
  if(w == W.size()) return ret = (s == S.size());
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(W[w] == '*')
    for(int skip = 0; skip + s <= S.size(); ++skip)
      if(matchMemoized(w + 1, s + skip))
        return ret = 1;
  // 3. 이 외의 경우에는 모두 대응되지 않는다.
  return ret = 0;
}
```

* ### 다른 분해 방법
#### &nbsp;다른 분해 방식을 사용하면 이 문제를 O(n^2)시간에 풀 수 있다.

## 04. 전통적 최적화 문제들
#### &nbsp;동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제에 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기보다 좀더 효율적으로 동적 계획법을 구현할 수 있다.

* ### 예제: 삼각형 위의 최대 경로(문제 ID: TRIANGLEPATH, 난이도: 하)
#### 6
#### 1 2
#### 3 7 4
#### &nbsp;위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

* ### 개인적 풀이
#### &nbsp;일단 완전 탐색을 통해서 아래로 갈 것인지 아니면 오른쪽 아래로 갈 것인지 찾아내면 될 것 같다.
```c++
int n;
int board[100][100];
int boardMaxSum[100][100];

int findMaxSum(int y, int x) {
  // 기저 사례: 삼각형이 아닌 부분을 참조하려 했을 때
  if(y >= n || x > y + 1 || y < 0 || x < 0) return 0;
  
  // x - 1값이 0 미만 일때
  if(x - 1 < 0) {
    // y - 1값이 0미만 일 때
    if(y - 1 < 0) {
      boardMaxSum[y][x] = board[y][x];
    } else {
      boardMaxSum[y][x] = board[y][x] + board[y - 1][x];
    }
  } else {
    // 특정 [y][x]에서의 최대 값은 [y - 1][x - 1]와 [y - 1][x]중 큰 값에 [y][x]값을 더 한 것이다.
    if(boardMaxSum[y - 1][x - 1] > boardMaxSum[y - 1][x]) {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x - 1];
    } else {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x];
    }
  }

  // 아래로 이동
  findMaxSum(y + 1, x);
  // 오른쪽 아래로 이동
  findMaxSum(y + 1, x + 1);
};
```
> 이런식으로 재귀 호출을 하게 되면 계산 되지 않은 값을 참조하는 경우가 생기기 때문에 안된다.

* ### 완전 탐색으로 시작하기
#### &nbsp;재귀 호출을 하는데 현재 위치와 지금가지 만난 숫자들의 함을 전달한다. pathSum(y, x, sum)이 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum일 때, 이 결로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환한다.

* ### 무식하게 메모이제이션 적용하기
#### &nbsp;n개의 가로줄이 있으면 가능한 경로의 수는 2^(n - 1)이다. 이때 n이 100정도만 돼도 계산할 수 없다. 다음과 같은 코드를 보자.
```c++
// MAX_NUMBER: 한 칸에 들어갈 숫자의 최대치
int n, triangle[100][100];
int cache[100][100][MAX_NUMBER * 100 + 1];
// y, x 위치까지 내려오기 전에 만난 숫자들의 합이 sum일 때 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로를 반환한다.
int path1(int y, int x, int sum) {
  // 기저 사례: 맨 아래 줄까지 도달했을 경우
  if(y == n - 1) return sum + triangle[y][x];
  // 메모이제이션
  int& ret = cache[y][x][sum];
  if(ret != -1) return ret;
  sum += triangle[y][x];
  return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
```
#### 이 코드는 완전 탐색과 다를 바가 없다.

* ### 입력 걸러내기
#### &nbsp;재귀 함수의 입력을 다음과 같이 두 부류로 나눠본다.
#### 1. y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 이 두 입력이 정해지면 앞으로 우리가 만들 수 있는 경로들이 정해진다. 따라서 이들은 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들이다.
#### 2. 반면 sum은 지금가지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. sum은 지금가지 풀었던 조각들에 대한 정보를 주는 입력이다.
#### path2(y, x)는 y, x에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.
```c++
int n, triangle[100][100];
int cache2[100][100];
// (y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path2(int y, int x) {
  // 기저 사례
  if(y == n - 1) return triangle[y][x];
  //메모이제이션
  int& ret = cache2[y][x];
  if(ret != -1) return ret;
  return ret = max(path2(y + 1, x), path2(y + 1, x + 1)) + triangle[y][x];
}
```
#### 0, 0부터 내려가는 것이 아닌 마지막 줄부터 올라온다.

* ### 내가 짠 코드와 비교해보기
#### &nbsp;해야하는 방향성은 알겠지만 코드로 구현하는 것이 매우 힘들다. 지속적으로 틀린다. 책에 써져 있는 코드는 깔끔하게 잘 써져 있어서 좋은 듯 하다.

* ### 이론적 배경: 최적 부분 구조
#### &nbsp;최적화가 가능했던 이유는 sum이라는 정보가 (y, x)에서 맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다는 사실을 파악한 덕분이다. 지금 까지 어던 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관 없다. 이것은 효율적인 동적 계획법 알고리즘을 적용하기 위해 아주 중요한 조건이다. 최적 부분 구조(Optimal substructure)이라고 불린다.

* ### 예제: 최대 증가 부분 수열(문제 ID: LIS, 난이도: 하)
#### &nbsp;어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다. 어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라. 어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

* ### 개인적 풀이
#### &nbsp;이 문제도 위의 문제와 유사하게 풀면 될 것 같다. 메모이제이션을 이용하며 현재 값보다 큰 값을 찾고 그 위치에서 다시 큰 값을 찾으며 최대 길이를 찾는다.

```c++
int length, sequence[500];
int cache[500];

int maxLength(int index) {
  // 기저 사례
  if(index >= length) return 0;

  //메모이제이션
  int& ret = cache[index + 1];
  if(ret != -1) return ret;

  for(int i = index + 1; i < length; i++) {
    if(sequence[index] < sequence[i]) {
      if(ret < maxLength(i) + 1){
        ret = maxLength(i) + 1;
      }
    }
  }

  return ret;
}
```

* ### 완전 탐색에서 시작하기
#### &nbsp;최대 증가 수열을 찾는 문제를 숫자 하나씩으로 조각낸 뒤, 한 조각에서 숫자 하나씩을 선택하는 완전 탐색 알고리즘을 만든다. lis(A)는 수열 A를 입력 받아 LIS의 길이를 반환한다.
```c++
int lis(const vector<int>& A) {
  // 기저 사례: A가 텅 비어 있을 때
  if(A.empty()) return 0;
  int ret = 0;
  for(int i = 0; i < A.size(); ++i) {
    vector<int> B;
    for(int j = i + 1; j < A.size(); ++j)
      if(A[i] < A[j])
        B.push_back(A[j]);
    ret = max(ret, 1 + lis(B));
  }
  return ret;
}
```

* ### 입력 손보기
#### &nbsp;A는 항상 다음 두 가지 중 하나가 된다.
#### 1. 원래 주어진 수열 S
#### 2. 원래 주어진 수열의 원소 S[i]에 대해, S[i + 1...] 부분 수열에서 S[i]보다 큰 수들만을 포함하는 부분 수열
#### S[start]는 S[start]보다 뒤에 있고 큰 수들 중 하나를 다음 숫자로 결정한 뒤, 여기서 시작하는 부분 증가 수열의 최대치를 구한다.
```c++
int n;
int cache[100], S[100];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis2(int start) {
  int& ret = cache[start];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  for(int next = start + 1; next < n; ++next) {
    if(S[start] < S[next])
      ret = max(ret, lis2(next) + 1);
  }
  return ret;
}
```

* ### 시작 위치 고정하기
```c++
int n;
int cache[101], S[101];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis3(int start) {
  int& ret = cache[start + 1];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  for(int next = start + 1; next < n; ++next) {
    if(S[start] < S[next])
      ret = max(ret, lis3(next) + 1);
  }
  return ret;
}
```

* ### 내가 짠 코드와 비교해보기
#### &nbsp;어느 정도의 방향성이나 생각하는 방향은 다 맞은 것 같다. 하지만 크기 비교를 위해서 if문 대신 max를 사용하는 것이 앞으로도 더 좋을 것 같다. 또한 위에서 나온 템플릿을 잘 외워야 할 것 같다.

* ### 더 빠른 해법
#### &nbsp;O(nlgn)에 찾을 수 있다.

* ### 최적화 문제 동적 계획법 레시피
#### 1. 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다.
#### 2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환한도록 부분 문제 정의를 바꾼다.
#### 3. 가능한 한 중복되는 부분 문제를 많이 만들어야 한다. 이러면 메모이제이션을 최대한도로 활용할 수 있다.
#### 4. 입력이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 한다.
#### 5. 메모이제이션을 적용한다.

## 05. 문제: 합친 LIS(문제 ID: JLIS, 난이도: 하)
#### &nbsp;어떤 수열에서 0개 이상의 숫자를 지운 결과를 원 수열의 부분 수열이라고 부릅니다. 예를 들어 '4 7 6'은 '4 3 7 6 9'의 부분 수열입니다. 중복된 숫자가 없고 오름 차순으로 정렬되어 있는 부분 수열들을 가리켜 증가 부분 수열이라고 부르지요. 예를 들어 '3 6 9'는 앞의 수열의 증가 부분 수열입니다. 두 개의 정수 수열 A 와 B 에서 각각 증가 부분 수열을 얻은 뒤 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 부르기로 합시다. 이 중 가장 긴 수열을 합친 LIS(JLIS, Joined Longest Increasing Subsequence)이라고 부릅시다. 예를 들어 '1 3 4 7 9' 은 '1 9 4' 와 '3 4 7' 의 JLIS입니다. '1 9' 와 '3 4 7' 을 합쳐 '1 3 4 7 9'를 얻을 수 있기 때문이지요. A 와 B 가 주어질 때, JLIS의 길이를 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 c ( 1 <= c <= 50 ) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 A 와 B 의 길이 n 과 m 이 주어집니다 (1 <= n,m <= 100). 다음 줄에는 n 개의 정수로 A 의 원소들이, 그 다음 줄에는 m 개의 정수로 B 의 원소들이 주어집니다. 모든 원소들은 32비트 부호 있는 정수에 저장할 수 있습니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 한 줄에, JLIS 의 길이를 출력합니다.

* ### 개인적 풀이
#### &nbsp;이 문제에서 조심해야 할 부분은 두개의 부분 수열에서 겹치는 숫자가 있는 경우다. 만약 a, b라는 최대 길이 부분 수열이 있는데 이 두개가 거의 혹은 완전 똑같다면, 합친 부분 수열은 최대의 길이가 아닌 수열이 될 것 이다. 첫번째로 가장 긴 합친 부분 수열을 만들 수 있는 알고리즘을 생각해 본다. 이때 최대 부분 수열을 구하는 함수와 다른 점은 배열이 두개라 모든 값들을 한번씩 맨 앞으로 배치해 봤을 때 메모이제이션 하는 것을 주의 하면 된다.
```c++
// 메모이제이션
int cache[2][101], s[2][101];
int length1, length2;

int jlis(int choiceString, int start) {
  // 기저 사례
  if(string > 100) return 0;
  int& ret = cache[choiceString][start + 1];
  if(ret != -1) return ret;
  
  int index1, index2 = 0;

  if(choiceString == 0) {
    index1 = start;
  } else {
    index2 = start;
  }

  for(int i = index1; i < length1; i++) {
    for(int j = index2; j < length2; j++) {
      // 두번째 문자열에서 부분 수열 찾기
      if(s[choiceString][i] < s[1][j]) {
        ret = max(ret, jlis(1, j + 1) + 1);
      }
    }
    // 첫번째 문자열에서 부분 수열 찾기
    if(s[choiceString][i] < s[0][j]) {
      ret = max(ret, jlis(0, i + 1) + 1);
    }
  }
  
  return ret;
}
```

## 06. 풀이: 합친LIS

* ### 탐욕법으로는 안 된다
#### &nbsp;이 문제는 LIS 찾기 문제의 확장판이다. 두 수열의 LIS를 찾아서 합치는 것 만으로는 해결할 수 없다.

* ### 비슷한 문제를 풀어 본 적이 있군요
#### &nbsp;jlis(indexA, indexB) == A[indexA]와 B[indexB]에서 시작하는 합친 증가 부분 수열의 최대 길이라 한다.
```c++
// 입력이 32비트 부호 있는 정수의 모든 값을 가질 수 있으므로 인위적인 최소치는 64비트여야 한다.
const long long NEGINF = numeric_limits<long long>::min();
int n, m, A[100], B[100];
int cache[101][101];
// min(A[indexA], B[indexB]), max(A[indexA], B[indexB])로 시작하는 합친 증가 부분 수열의 최대 길이를 반환한다.
// 단 indexA == indexB == -1 혹은 A[indexA] != B[indexB]라고 가정한다.
int jlis(int indexA, int indexB) {
  // 메모이제이션
  int& ret = cache[indexA + 1][indexB + 1];
  if(ret != -1) return ret;
  // A[indexA], B[indexB]가 이미 존재하므로 2개는 항상 있다.
  ret = 2;
  long long a = (indexA == -1 ? NEGINF : A[indexA]);
  long long b = (indexB == -1 ? NEGINF : B[indexB]);
  long long maxElement = max(a, b);
  // 다음 원소를 찾는다
  for(int nextA = indexA + 1; nextA < n; ++nextA)
    if(maxElement < A[nextA])
      ret = max(ret, jlis(nextA, nextB) + 1);
  for(int nextB = indexB + 1; nextB < m; ++nextB)
    if(maxElement < B[nextB])
      ret = max(ret, jlis(indexA, nextB) + 1);
  return ret;
}
```

* ### 내가 짠 코드와 비교해 보기
#### &nbsp;생각은 비슷했지만 내가 짠 코드는 동작하지 않는다. 왜냐하면 첫번째 값만 고정시키고 나머지 원소들을 비교하려고 했기 때문이다. 이렇게 되면 크기 비교도 잘 작동하지 못한다.

## 07. 문제: 원주율 외우기(문제 ID: PI, 난이도: 하)
#### &nbsp;가끔 TV 에 보면 원주율을 몇만 자리까지 줄줄 외우는 신동들이 등장하곤 합니다. 이들이 이 수를 외우기 위해 사용하는 방법 중 하나로, 숫자를 몇 자리 이상 끊어 외우는 것이 있습니다. 이들은 숫자를 세 자리에서 다섯 자리까지로 끊어서 외우는데, 가능하면 55555 나 123 같이 외우기 쉬운 조각들이 많이 등장하는 방법을 택하곤 합니다. 이 때, 각 조각들의 난이도는 다음과 같이 정해집니다.
#### 1. 모든 숫자가 같을 때 (예: 333, 5555) 난이도: 1
#### 2. 숫자가 1씩 단조 증가하거나 단조 감소할 때 (예: 23456, 3210) 난이도: 2
#### 3. 두 개의 숫자가 번갈아 가며 출현할 때 (예: 323, 54545) 난이도: 4
#### 4. 숫자가 등차 수열을 이룰 때 (예: 147, 8642) 난이도: 5
#### 5. 그 외의 경우 난이도: 10
#### 원주율의 일부가 입력으로 주어질 때, 난이도의 합을 최소화하도록 숫자들을 3자리에서 5자리까지 끊어 읽고 싶습니다. 최소의 난이도를 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어집니다. 각 테스트 케이스는 8글자 이상 10000글자 이하의 숫자로 주어집니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 한 줄에 최소의 난이도를 출력합니다.

* ### 개인적 풀이
#### &nbsp;완전 탐색을 하기위해서 문자열 첫부분을 3자리, 4자리, 5자리, 끊어서 각각의 남은 문자열에 대해서 다시 3자리, 4자리, 5자리 씩 끊어서 확인을 해보면 될 것 같다. 다만 문자열 길이가 최대 10000까지 된다. 그래서 메모이제이션을 이용해 각각의 남은 배열에 대한 최소의 난이도를 계속 저장한다.
```c++
int cache[10000];
int pi[10000];

int checkLevel(int index, int checkLength) {
  int check1 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] == pi[index + i + 1]) check1++;
  }
  if(check1 == checkLength - 1) return 1;

  int check2 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] - pi[index + i + 1] == 1) check2++;
    if(pi[index + i] - pi[index + i + 1] == -1) check2--;
  }
  if(check2 == (-1 * checkLength) + 1 || check2 == checkLength - 1) return 2;

  int check3 = 0;
  if(checkLength == 3) {
    if(pi[index] == pi[index + 2]) check3++;
  } else if(checkLength == 4) {
    if(pi[index] == pi[index + 2] && pi[index + 1] == pi[index + 3]) check3++;
  } else {
    if(pi[index] == pi[index + 2] && pi[index] == pi[index + 3] && pi[index + 1] == pi[index + 3]) check3++;
  }
  if(check3 == 1) return 4;

  int check4 = 0;
  for(int i = 0; i < checkLength - 1; i++) {
    if(pi[index + i] - pi[index + i + 1] == pi[index] - pi[index + 1]) check4++;
  }
  if(check4 == checkLength - 1) return 5;

  return 10;
}

int minPiLevel(int index, int checkLength) {
  if(index > 10000) return 10;
  
  int& ret = cache[index];
  if(ret != -1) return ret;
  
  int level = checkLevel(index, checkLength);
  ret += level;

  for(int i = 0; i < 3; i++) {
    ret = min(ret, minPiLevel(index + checkLenth, 3 + i));
  }

  return ret;
}
```

## 08. 풀이: 원주율 외우기

* ### 일만 자리나 외우라고?
#### &nbsp;입력의 크기를 보면 어떤 방식이든지 완전 탐색으로 이 문제를 해결하기란 불가능하다는 것을 본능 적으로 알 수 있다. 길이가 7인 수열은 두 가지 방법으로 쪼갤 수 있는데 이런 수열이 n개 있으면 쪼갤 수 있는 방법의 수는 2^n개가 되는데, 길이가 10000인 수열에는 1,428개가 들어갈 수 있다.

* ### 메모이제이션의 적용
#### &nbsp;전체 문제의 최적해는 다음 세 경우 중 가장 작은 값이 된다.
#### 01. 길이 3인 조각의 난이도 + 3글자 빼고 나머지 수열에 대한 최적해
#### 02. 길이 4인 조각의 난이도 + 4글자 빼고 나머지 수열에 대한 최적해
#### 03. 길이 5인 조각의 난이도 + 5글자 빼고 나머지 수열에 대한 최적해
#### 나머지 수열의 최적해를 구할 때 앞의 부분을 어떤 식으로 쪼갰는지는 중요하지 않다.

* ### 구현
```c++
string N;
// N[a..b]구간의 난이도를 반환한다.
int classify(int a, int b);
int cache[10002];
// 수열 N[begin..]를 외우는 방법 중 난이도의 최솟합을 출력한다.
int memorize(int begin) {
  // 기저 사례: 수열의 끝에 도달했을 경우
  if(begin == N.size()) return 0;
  // 메모이제이션
  int& ret = cache[begin];
  if(ret != -1) return ret;
  ret = INF;
  for(int L = 3; L <= 5; ++L)
    if(begin + L <= N.size())
      ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));
  return ret;
}
```

* ### 내가 짠 코드와 비교해 보기
#### &nbsp;index까지의 최솟값을 구해서 메모이제이션을 이용하는 방법은 똑같다. 다만 내가 짠 코드는 3글자에서 5글자를 변수 length 인자값으로 넘겨서 사용했고, ret을 -1로 초기화는 했지만 최솟값을 찾는 문제였기에 ret에 최대 값을 넣었어야 했다.

## 09. 문제: Quantization(문제 ID: QUANTIZE, 난이도: 중)
#### &nbsp;Quantization (양자화) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 갖는 값들로 근사해 표현함으로써 자료를 손실 압축하는 과정을 말한다. 예를 들어 16비트 JPG 파일을 4컬러 GIF 파일로 변환하는 것은 RGB 색 공간의 색들을 4컬러 중의 하나로 양자화하는 것이고, 키가 161, 164, 170, 178 인 학생 넷을 '160대 둘, 170대 둘' 이라고 축약해 표현하는 것 또한 양자화라고 할 수 있다. 1000 이하의 자연수들로 구성된 수열을 최대 S종류 의 값만을 사용하도록 양자화하고 싶다. 이 때 양자화된 숫자는 원래 수열에 없는 숫자일 수도 있다. 양자화를 하는 방법은 여러 가지가 있다. 수열 1 2 3 4 5 6 7 8 9 10 을 2개의 숫자만을 써서 표현하려면, 3 3 3 3 3 7 7 7 7 7 과 같이 할 수도 있고, 1 1 1 1 1 10 10 10 10 10 으로 할 수도 있다. 우리는 이 중, 각 숫자별 오차 제곱의 합을 최소화하는 양자화 결과를 알고 싶다. 예를 들어, 수열 1 2 3 4 5 를 1 1 3 3 3 으로 양자화하면 오차 제곱의 합은 0+1+0+1+4=6 이 되고, 2 2 2 4 4 로 양자화하면 오차 제곱의 합은 1+0+1+0+1=3 이 된다. 수열과 S 가 주어질 때, 가능한 오차 제곱의 합의 최소값을 구하는 프로그램을 작성하시오.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열의 길이 N (1 <= N <= 100), 사용할 숫자의 수 S (1 <= S <= 10) 이 주어진다. 그 다음 줄에 N개의 정수로 수열의 숫자들이 주어진다. 수열의 모든 수는 1000 이하의 자연수이다.

* ### 출력
#### &nbsp;각 테스트 케이스마다, 주어진 수열을 최대 S 개의 수로 양자화할 때 오차 제곱의 합의 최소값을 출력한다.

* ### 개인적 풀이
#### &nbsp;일단 완전 탐색법으로는 1 ~ 1000중 S개의 자연수를 골라서 배열 N을 S부분으로 나눠서 오차 제곱의 합을 구하고 최솟값을 찾아낸다.

## 10. 풀이: Quantization

* ### 하던 대로는 안 된다
#### &nbsp;단순하게 생각해 보면 양자화된 결과 수열을 답으로 생각하고, 맨 앞의 숫자에서부터 하나씩 채워 나가는 접근 방법을 택하게 된다.
#### quantize(A, U) = U가 지금까지 한 번 이상 사용한 숫자들의 집합일 때 A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합.
#### 하지만 이런 완전 탐색 코드는 너무 오래 걸려서 답을 구할 수 없다.

* ### 답의 형태 제한하기
#### &nbsp;답의 구조를 예측하고 그것을 강제한다. 주어진 수열을 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다. 따라서 이 문제는 이제 주어진 수열을 s개의 묶음으로 나누는 문제가 된다. 매 재귀 호출 때마다, 첫 묶음의 크기가 얼마일지를 결정하면 된다. from번째 이후 숫자들을 parts개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 quantize(from, parts)가 있다고 한다. 첫 번째 묶음의 크기가 size일 떄의 최소 오류는 minError(from, from + size + 1) + quantize(from + size, parts - 1)이 된다.

* ### 한 개의 구간에 대한 답 찾기
#### &nbsp;minError(a, b)에서 해야 하는 일은 크게 두 가지이다.
#### 01. 주어진 구간을 어떤 수로 표현해야 할지 결정하기
#### 02. 결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기
#### 모든 값의 평균을 사용하면 오차를 최소화할수 있다.

* ### 구현
```c++
const int INF = 987654321;
// A[]: 양자화해야 할 수열, 정렬한 상태
// pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0]^2..A[i]^2의 합
// pSqSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2..A[i]^2의 합
int n;
int A[101], pSum[101], pSqSum[101];
// A를 정렬하고 각 부분합을 계산한다.
void precalc() {
  sort(A, A + n);
  pSum[0] = A[0];
  pSqSum[0] = A[0] * A[0];
  for(int i = 1; i < n; ++i) {
    pSum[i] = pSum[i - 1] + A[i];
    pSqSum[i] = pSqSum[i - 1] + A[i] * A[i];
  }
}
// A[lo]..A[hi]구간을 하나의 숫자로 표현할 때 최소 오차 합을 계산한다.
int minError(int lo, int hi) {
  // 부분합을 이용해 A[lo] ~ A[hi]까지의 합을 구한다.
  int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo - 1]);
  int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo - 1]);
  // 평균을 반올림한 값으로 이 수들을 표현한다.
  int m = int(0.5 + (double)sum / (hi - lo + 1));
  // sum(A[i] - m) ^ 2를 전개한 결과를 부분 합으로 표현
  int ret = sqSum - 1 * m * sum + m * m * (hi - lo + 1);
  return ret;
}
int cache[101][11];
int quantize(int from, int parts) {
  // 기저 사례: 모든 숫자를 다 양자화 했을 때
  if(from == n) return 0;
  // 기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값을 반환한다.
  if(parts == 0) return INF;
  int& ret = cache[from][parts];
  if(ret != -1) return ret;
  ret = INF;
  // 조각의 길이를 변환시켜 가며 최소치를 찾는다.
  for(int partSize = 1; from + partSize <= n; ++partSize)
    ret = min(ret, minError(from, from + partSize - 1) + quantize(from + partSize, parts - 1));
  return ret;
}
```

## 11. 경우의 수와 확률
#### &nbsp;동적 계획접은 애초에 최적화 문제를 풀기 위해 고안되었지만, 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용된다.

* ### 오버플로에 유의하기
#### &nbsp;많은 경우 답이 32비트 정수형의 한계를 초과하기 십상이다.

* ### 예제: 타일링 방법의 수 세기(문제 ID: TILING2, 난이도: 하)
#### &nbsp;2xn 크기의 사각형을 2x1 크기의 사각형으로 빈틈없이 채우는 경우의 수를 구하는 프로그램을 작성하세요. n의 최대 값이 100이라고 할 때 타일을 채우는 방법의 수를 어떻게 셀 수 있을까?

* ### 개인적 풀이
#### &nbsp;타일을 놓는 방법은 세워서 하나를 두거나 눞혀서 2개를 두거나 두가지 경우의 수다. 따라서 완전 탐색을 이용해 재귀적으로 인자값으로 남은 칸을 수를 넘기고 세워서 두는 경우랑 눞혀서 2개를 두는 경우를 실행해 보면 될 것 같다. 또한 메모이 제이션을 통해서 이미 계산 해본 경우의 수는 저장해 재귀 호출을 하지 않고 사용한다.
```c++
int cache[101];

int counting(int remainSection) {
  if(remainSection == 0) return 1;
  int& ret = cache[remainSection];
  if(ret != -1) return ret;

  ret += counting(remainSection - 1);
  if(remainSection > 1) ret += counting(remainSection - 2);

  return ret;
}
```
* ### 풀이
#### &nbsp;완전 탐색을 이용해 모든 답을 만들면서 개수를 세어보는 함수를 작성 한 뒤, 메모이제이션을 이용해 동적 계획법 알고리즘으로 바꿔 본다. tiling(n)는 2 * n 크기의 사각형을 타일로 덮는 방법을 반환한다. 이때 다음과 같은 점화식이 성립한다. tiling(n) = tiling(n - 1) + tiling(n - 2). n이 100이면 경우의 수는 64비트 정수형의 표현 범위도 훌쩍 넘어가는 큰 값이 된다.
```c++
const int MOD = 1000000007;
int cache[101];
// 2 * width 크기의 사각형을 채우는 방법의 수를 MOD로 나눈 나머지를 반환한다.
int tiling(int width) {
  // 기저 사례: width가 1 이하일 때
  if(width <= 1) return 1;
  // 메모이제이션
  int& ret = cache[width];
  if(ret != -1) return ret;
  return ret = (tiling(width -2 ) + tiling(width - 1)) % MOD;
}
```
#### 이 알고리즘의 부분 문제의 수는 O(n)이고, 각각의 값을 계산하는 데 O(1)의 시간이 들기 때문에 전체 시간 복잡도는 O(n)이 된다.

* ### 예제: 삼각형 위의 최대 결로 개수 세기(문제 ID: TRIPATHCNT, 난이도: 중)
#### &nbsp;맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 숫자의 합이 가장 큰 경로는 하나가 아니라 여러 개일 수 있습니다. 예를 들어 위 삼각형에서는 {9, 7, 2, 6}과 {9, 7, 3, 5}의 합이 모두 최대인 24이고, {9, 7, 3, 5}는 두 번 등장하거든요. 삼각형이 주어질 때 최대 경로의 수를 세는 프로그램을 작성하세요.
#### 9
#### 5 7
#### 1 3 2
#### 3 5 5 6