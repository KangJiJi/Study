# Chain of Responsibility(책임 연쇄)

## 의도

&nbsp;메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴이다. 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 주려는 것이다.

## 동기

&nbsp;사용자가 정보를 선택하면 그 부분에 대한 도움말 정보를 얻을 수 있는 시스템을 생각해본다. 이때 도움말의 내용은 선택한 주체가 무엇이며, 현재 그 주체의 상황이 어떠한가에 따라 다르다. 만약 도움말이 없다면 일반적인 도움말이라도 제공해야한다. 즉, 도움말을 제공해야 할 객체가 도움말 요청을 보내는 객체에게 알려져 있지 않다. 따라서 도움말 요청을 발생시키는 객체와 도움말 정보를 제공하는 객체를 분리해야 할 필요가 있다.

책임 연쇄 패턴은 메시지 송신 측과 수신 측을 분리한다. 또한 요청을 처리하는 기회를 다른 객체에 분산한다.

## 활용성

- 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자인지 모를 때.
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

## 참여자

- Handler
- ConcreteHandler
- Client

## 협력 방법

&nbsp;사용자는 처리를 요청하고, 이 처리 요청은 실제로 그 요청을 받을 책임이 있는 ConcreteHandler 객체를 만날 때까지 정의된 연결 고리를 따라서 계속 전달됩니다.

## 결과

- 객체간의 행동적 결합도가 적어집니다.
- 객체에게 책임을 할당하는 데 유연성을 높일 수 있습니다.
- 메시지 수신이 보장되지는 않습니다.

## 구현

- 후속 처리자들의 연결 고리 구현하기
- 후속 처리자 연결하기
- 처리 요청의 표현부를 정의하기
- 스몰토크를 사용할 때 자동 전달 기능을 이용하기

## 예제 코드

&nbsp;`HelpHandler`클래스는 도움말 요청을 처리하는 데 필요한 인터페이스를 정의한다.

```javascript
class HelpHandler {
  hasHelp() {}
  setHandler() {}
  handleHelp() {}
}
```

`HelpHandler`클래스를 상속받는 `Widget`를 정의한다. 그리고 `Widget`을 상속받는 `Button`클래스를 정의한다.

```javascript
class Widget extends HelpHandler {}
class Button extends Widget {
  handleHelp() {
    if (hasHelp()) {
      // 도움말 보여주기
    } else {
      super.handleHelp();
    }
  }
}
```

`Button`의 `handleHelp`메서드는 도움말이 있는지 확인한다. 있다면 도움말을 보여주고, 없다면 요청은 다음 객체에게 전달된다.

## 관련 패턴

&nbsp;책임 연쇄 패턴은 복합체 패턴과 함께 사용딘다. 이때 구성요소의 부모는 후속 처리자처럼 동작한다.
