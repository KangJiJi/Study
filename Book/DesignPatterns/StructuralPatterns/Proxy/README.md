# Proxy(프록시)

## 의도

&nbsp;다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둔다.

## 동기

&nbsp;어떤 객체데 대한 접근을 제어하는 이유는 그 객체를 사용할 수 있을 때까지 객체 생성과 초기화에 들어가는 비용 및 시간 때문이다. 그래픽 편집기에서 이미지와 같은 그래픽 객체는 생성에 많은 비용이 든다. 하지만 그래픽 객체가 있던 없던 문서를 읽는 것은 빠르게 진행돼야 한다. 따라서 이미지 프로식를 만들어서 사용한다. 프록시는 이미지처럼 동작하고, 필요할 때 이미지 인스턴스를 만들어 낸다. `Draw()`연산을 통해서 화면에 그리기 원할때만 실제 이미지를 생성한다. 이때 이미지의 넓이와 높이는 '한계 정보'로 관리한다.

## 활용성

&nbsp;프록시 패턴은 단순한 포인터보다는 정교한 객체 참조자가 필요할 때 사용한다.

- 원격지 프록시
- 가상 프록시
- 보호용 프록시
- 스마트 참조자

## 참여자

- Proxy
- Subject
- RealSubject

## 협력 방법

&nbsp;프록시 클래스는 자신이 받은 요청을 RealSubject 객체에 전달합니다.

## 결과

- 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있다.
- 가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화할 수 있다.
- 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임진다. 객체를 생성할 것인지 삭제할 것인지를 관리한다.

기록 시점 복사(Copy-on-write)라는 최적화도 있다. 이 최적화는 사본이 변경되지 않으면 원본을 그대로 보여주고, 수정될 때만 사본을 만드는 것이다.

## 구현

- c++에서는 멤버 접근 연산자를 오버로드한다.
- 스몰토크에 정의된 `doesNotUnderstand`를 사용한다.
- Proxy가 항상 자신이 상대할 실제 대상을 알 필요는 없다.

## 예제 코드

&nbsp;첫번째는 가상 프록시에 대한 예제입니다.

`Graphic`클래스는 그래픽 객체에 대한 인터페이스를 정의한다.

```javascript
class Graphic {
  draw() {}
  handleMouse() {}
  getExtend() {}
  load() {}
  save() {}
}
```

`Image`클래스는 `Graphic`클래스를 상속받습니다. 또한 생성자에서 이미지를 로드합니다.

```javascript
class Image extends Graphic {
  constructor() {
    // load image
  }
  draw() {}
  handleMouse() {}
  getExtend() {}
  load() {}
  save() {}
}
```

`ImageProxy`는 `Image`와 같은 인터페스를 가진다.

```javascript
class ImageProxy extends Graphic {
  constructor(imageFile) {
    // 이미지 파일 주소를 저장한다.
  }
  draw() {}
  handleMouse() {}
  getExtend() {}
  load() {}
  save() {}
  getImage() {}
}
```

`getExtend`, `Draw` 그리고 `HandleMouse`와 같은 메서드는 `getImage`메서드를 통해서 실제 `Image`클래스의 메서드를 호출하게끔 구현한다.

두번째는 `doseNotUnderstand`를 사용하는 프록시다. 하지만 스몰토크 한정이기 때문에 기록하지 않는다.

## 관련 패턴

&nbsp;적응자는 원래 객체와 다른 새로운 인터페이스를 제공하지만 프록시는 그렇지 않다. 장식자는 하나 이상의 서비스를 추가하는 것이 목적이고, 프록시는 접근을 제어하는 것이 목적이다.
