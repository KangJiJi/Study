# Adapter(적응자)

## 의도

&nbsp;클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시킨다. 서로 일치하지 않는 인터페이스를 가지는 클래스들을 함께 동작시킨다.

## 동기

&nbsp;가끔 응용프로그램의 인터페이스와 툴킷에 정의된 인터페이스가 일치하지 않는 경우가 있다. 즉, 서로 일치하지 않는 인터페이스를 갖는 클래스들을 잘 통합해야 할 때 사용한다. `TextView`(Adaptee)클래스를 `Shape`(Target)클래스에 맞게 연결하려면 `TextShape`(Adapter)가 `TextView`와 `Shape`를 상속 받는 `클래스 버전의 적응자`, `TextShape`가 `Shape`를 상속받고 `TextView`를 포함하는 `객체 버전의 적응자` 두 가지가 있다.

## 활용성

- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 재사용 하려는 라이브러리를 수정할 수 없을 때
- 여러개의 서브 클래스를 모두 상속받을 수 없을 때(객체 버전 적응자에 사용)

## 참여자

- Target
- Client
- Adaptee
- Adapter

## 협력 방법

&nbsp;사용자는 적응자 인스턴스의 연산을 호출하고, 호출된 연산은 적응자대상의 연산을 호출한다.

## 결과

&nbsp;클래스 적응자와 객체 적응자는 각각 장단점이 있다.

- 클래스 적응자
  - Adaptee의 서브클래스의 모든 기능을 사용할 수 없다.
  - Adaptee의 행동을 재정의할 수 있다.
  - Adaptee의 포인터는 필요 없다.
- 객체 적응자
  - 여러개의 Adaptee를 포함할 수 있다.
  - Adaptee의 행동을 재정의하기 매우 어렵다.

추가적으로 고려해야할 사항들이다.

- Adapter 클래스가 실제 적응 작업을 위해 들어가는 노동력이 얼마나 되나?
- 대체 가능(Pluggable) 적응자(인터페이스의 변경이 가능하도록 만들 수 있음).
- 양방향 적응자를 통한 투명성 제공(Target과 Adaptee 인터페이스 모두를 만족시키고 싶을 때).

## 구현

- 클래스 적응자를 C++로 구현.
- 대체 가능 적응자.
  - Adaptee에 정의된 인터페이스들 중 적응이 필요한 최소 집합을 만든다.
    - 추상 연산을 사용하는 방법
    - 위임 객체를 사용하는 방법
    - 매개변수화된 적응자를 사용하는 방법

## 예제 코드

```javascript
class Shape {
  boundingBox() {}
  createManipulator() {}
}

class TextView {
  getOrigin() {}
  getExtent() {}
  isEmpty() {}
}
```

위와 같은 상황에서 적응자를 통해 `TextView`가 `Shape`에 맞는 형태로 변경한다. 이때 클래스 적응자는 다중 상속을 이용하고, 객체 적응자는 합성을 이용한다.

```javascript
// 객체 적응자
class TextShpae extends Shape {
  constructor() {
    super();
    this._textView = new TextView();
  }

  // ...
}
```

## 관련 패턴

&nbsp; 가교 패턴과 구조가 유사하지만 사용 목적이 다르다. 가교 패턴은 각각의 구현이 만족할 추상 개념을 분리하려 서로에게 영향을 주지 않고 각각을 확장할 수있도록 하는 것이다. 반면 적응자 패턴은 존재하는 객체의 인터페이스를 변경하려는 것이다. 장식자 패턴은 인터페이스의 변경 없이도 새로운 행동을 추가할 수 있도록 한다.
