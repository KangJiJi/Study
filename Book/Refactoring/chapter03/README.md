# 코드에서 나는 악취

&nbsp;리팩터링을 언제 시작하고 언제 그만할지 판단하는 것은 중요하다. 그리고 리팩터링이 필요한 코드들에는 일정한 패턴이 있다.

## 기이한 이름(Mysterious Name)

&nbsp;코드는 단순하고 명료하게 작성해야 한다. 그리고 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 중복 코드(Duplicated Code)

&nbsp;똑같은 코드 구조를 통합해서 더 나은 프로그램을 만들 수 있다.

## 긴 함수(Long Function)

&nbsp;`간접 호출`의 효과는 함수를 짧게 구성할 때 나오는 것이다. 또한 함수 이름을 잘 지어두면 함수 본문을 볼 필요가 없다. 그러기 위해서는 함수를 적극적으로 쪼개야 한다.

## 긴 매개변수 목록(Long Parameter List)

&nbsp;매개변수 목록이 길어지면 이해하기 어려울 때가 많다. 따라서 여러 방법을 이용해서 줄이도록 하자.

## 전역 데이터(Global Data)

&nbsp;전역 데이터는 버그 발생시 원인이 되는 코드를 찾아내기 어렵게 만든다. 다른 코드를 오염시킬 가능성이 있는 변수를 찾아서 접근을 통제한다. 전역데이터가 조금이라도 있으면 캡슐화하는 편이 좋다.

## 가변 데이터(Mutable Data)

&nbsp;데이터 변경은 예상치 못한 결과나 버그로 이어지는 경우가 종종 있다. 그래서 함수형 프로그래밍을 사용한다. 하지만 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.

## 뒤엉킨 변경(Divergent Change)

&nbsp;코드를 수정할 때 한 군데를 찾아서 수정하는 것으로 해결할 수 없다면 뒤엉킨 변경일 수도 있다. 뒤엉킨 변경은 SRP가 지켜지지 않을 때 나타난다.

## 산탄총 수술(Shotgun Surgery)

&nbsp;산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. 자잘하게 수정해야하는 클래스가 많을 때 풍긴다. 어설프게 분리된 로직을 하나로 합치는 것도 좋은 방법이다.

## 기능 편애(Feature Envy)

&nbsp;기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다. 이는 전략 패턴이나 방문자 패턴을 이용해서도 해결할 수 있다.

## 데이터 뭉치(Data Clumps)

&nbsp;데이터 항목 서너 개가 여러 곳에서 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 이러한 데이터 뭉치는 따로 보금자리를 마련해줘야 한다. 값 하나를 삭제했을 때 나머지 데이터만으로 의미가 없다면 객체로 바꿔줘야 하는 데이터 뭉치다.

## 기본형 집착(Primitive Obsession)

&nbsp;기본형 타입의 데이터를 객체로 바꿔줘야 한다.

## 반복되는 switch문(Repeated Switches)

&nbsp;중복된 switch문은 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 한다. 이럴 때 다형성을 이용해서 해결해야 한다.

## 반복문(Loops)

&nbsp;일급 함수(First-class function)을 지원하는 언어가 많아서 반복문을 제거할 수 있게 됐다.

## 성의 없는 요소(Lazy Element)

&nbsp;프로그램의 요소(언어에서 제공하는 함수, 클래스 인터페이스 등 코드 구조를 잡는 데 활용되는 요소)가 의미가 없어진다면 제거해야 한다.

## 추측성 일반화(Speculative Generality)

&nbsp;'나중에 필요할 거야'라는 생각에서 나오는 Hooking포인트와 케이스 처리 로직에서 나타나는 냄새다. 실제로 사용이 되면 다행이지만, 그렇지 않다면 낭비일 뿐이다.

## 임시 필드(Temporary Field)

&nbsp;가끔 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있는데 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다.

## 메시지 체인(Message Chains)

&nbsp;메시지 체인은 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다. 이 문제는 위임 숨기기로 해결해야 한다.

## 중개자(Middle Man)

&nbsp;캡슐화에서 위임이 자주 활용된다. 하지만 지나치면 문제가 된다. 이럴때는 실제로 일을 하는 객체와 직접 소통하게 한다.

## 내부자 거래(Insider Trading)

&nbsp;모듈 사이의 데이터 거래는 양을 최소로 줄이고 투명하게 처리해야 한다.

## 거대한 클래스(Large Class)

&nbsp;클래스가 너무 많은 일을 하면 필드 수가 늘어나고, 중복 코드가 생기기 쉽다. 필드 일부를 묶거나, 클래스 안에서 자체적으로 중복을 제거한다.

## 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces)

&nbsp;클래스의 큰 장점은 다른 클래스로 교체할 수 있다는 것이다. 하지만 인터페이스가 같아야 한다. 따라서 메서드 시그니처를 일치시키고 인터페이스가 같아질 때까지 필요한 동작을 클래스 안으로 밀어 넣는다.

## 데이터 클래스(Data Class)

&nbsp;데이터 클래스는 Getter와 Setter로만 구성된 클래스다. 이런 클래스에 public 필드가 있다면 숨기고, 변경하면 안 되는 필드는 접근을 봉쇄한다. 그러나 데이터 클래스는 필요한 동작이 다른 곳에 정의돼 있다는 신호일 수 있다.

## 상속 포기(Refused Bequest)

&nbsp;이는 서브클래스가 부모의 동작은 사용하고 인터페이스는 따르고 싶지 않을 때 나타난다.

## 주석(Comments)

&nbsp;주석이 많으면 악취가 풍길 수 있다. 따라서 주석이 필요 없는 코드로 리팩터링을 한다. 또한 주석은 확실하지 않은 부분에 남긴다.
