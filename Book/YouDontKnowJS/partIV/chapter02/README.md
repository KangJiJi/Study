# 콜백

&nbsp;함수는 콜백(Callback)역할을 한다. 큐에서 대기 중인 코드가 처리되자마자 본 프로그램으로 되돌아올 목적지기 때문이다. 콜백은 JS에서 가장 기본적인 비동기 패턴이다. 하지만 여러 단점 때문에 `Promise`가 나왔다. 우리는 왜 이렇게 변했는지 알아본다.

## 1. 연속성

&nbsp;다음 코드를 살펴보자.

```javascript
// A(전반부)
ajax("...", function(...) {
  // C(후반부)
})
// B(전반부)
```

전반부는 지금 후반부는 나중에 해당한다. 지금 덩이가 실행되면 `Ajax`호출이 끝날 때 이전 위치로 돌아와서 나머지 나중 덩이가 실행된다. 콜백은 프로그램의 연속성(Continuation)을 감싼(Wrapping) 혹은 캡슐화(Encapsulation)한 장치다.

## 2. 두뇌는 순차적이다

&nbsp;인간의 두뇌는 단일 스레드 방식의 이벤트 루프 큐처럼 작동한다. 각 작업을 아주 작고 짧은 덩이로 쪼개어 동시에(인터리빙) 처리하는 것이다.

### 실행 vs 계획

&nbsp;사람이 여러 가지 작업을 계획하는 방법과 두뇌가 이들을 처리하는 방식에는 차이가 있다. 'A 를 하고 B 를 하고 C 를 해야지'와 같은 계획은 비동기 이벤트처럼 보이지 않는다. 코드에서 문과 문이 이어진 동기 코드 작성은 게획을 하는 것과 비슷하다. 또한 두뇌는 빠른 콘텍스트 교환으로 작업을 처리한다.

인간은 단계별로 끊어 생각하는 경향이 있는데, 콜백으로는 단계별로 나타내기가 쉽지 않다.

### 중첩/연쇄된 콜백

&nbsp;다음은 콜백 지옥(Callback Hell)을 보여주는 코드다.

```javascript
listen('click', function handler(evt) {
  setTimeout(function request() {
    ajax('http://some.url.1', function response(text) {
      if (text === 'hello') {
        handler();
      } else if (text === 'world') {
        request();
      }
    });
  }, 500);
});
```

콜백 지옥은 들여쓰기와 무관하고 다른 심각한 문제를 안고 있다. 위 코드는 '클릭 이벤트 대기', '타이머 작동까지 대기', 'Ajax응답 받을 때까지 대기' 순으로 진행하고 되풀이된다. 다음과 같이 나눠볼 수 있다.

```javascript
// 지금
listen('click', function handler(evt) {
  // ...
});

// 나중
setTimeout(function request() {
  // ...
}, 500);

// 더 나중
ajax('http://some.url.1', function response(text) {
  // ...
});

// 결국
if (text === 'hello') {
  handler();
} else if (text === 'world') {
  request();
}
```

하지만 이런 선형적인 코드 추론에는 몇 가지 문제점이 있다.

첫째, 단순히 순차 실행될 경우는 많은 경우의 수 중 하나에 불과하다. 실무의 비동기 JS 프로그램에는 잡음이 섞인다. 그래서 선형적으로 코드를 추론하기 어렵다. 또한 하드 코딩한 콜백은 부실한 코드를 양산하고 코드가 복잡해져서 유지보수가 힘들어진다. 이것이 콜백 지옥이다.

## 3. 믿음성 문제

&nbsp;더 심각한 문제가 있다. 콜백 함수의 개념을 프로그램의 연속의 관점에서 다시 보자.

```javascript
// A(전반부)
ajax("...", function(...) {
  // C(후반부)
})
// B(전반부)
```

A와 B는 JS 메인 프로그램의 제어를 직접 받으며 '지금' 실행되지만 C는 다른 프로그램의 제어하에 '나중'에 실행된다. 이런 제어권 교환(Control Switch)는 콜백 중심적 설계 방식의 큰 문제점이다. `ajax`는 서드 파티가 제공한 유틸리티인 경우가 대부분이다. 이렇게 내가 작성하는 프로그램인데도 실행 흐름은 서드 파티에 의존해야하는 상황을 제어의 역전(Inversion of Control)이라 한다.

### 다섯 마리 콜백 이야기

&nbsp;고가의 TV를 판매하는 쇼핑몰의 전자상거래 결제 시스템을 구축하는 예시를 보자. 마지막 페이지에서 TV 구매 확인 버튼을 누르면 서드 파티 함수를 호출하여 구매 정보를 추적할 수 있게 돼 있다. 이 함수는 호출시 콜백 함수를 같이 넘겨야 한다. 이 콜백 함수는 신용 카드를 결제하고 감사 페이지로 이동하는 코드가 실행된다.

```javascript
analytics.trackPurchase(purchaseData, function () {
  chaargeCreditCard();
  displayThankyouPage();
});
```

잘 동작한다. 하지만 6개월 뒤 어떤 고객이 5번이나 똑같은 가격으로 결제되는 문제가 발생한다. 원인은 서드 파티 함수가 콜백 함수를 다섯 번이나 호출하도록 변경됐기 때문이다. 그래서 서드 파티 함수에 의존하지 않도록 코드를 바꾼다. 임시로 다음과 같이 변경한다.

```javascript
let tracked = false;

analytics.trackPurchase(purchaseData, function () {
  if (!tracked) {
    // 걸쇠
    tracked = true;
    chaargeCreditCard();
    displayThankyouPage();
  }
});
```

근데 서드 파티 함수가 콜백을 호출안한다면? 매우 큰일이다. 다음은 잘못 작동할 가능성이 있는 경우다.

- 콜백을 너무 일찍 부른다
- 콜백을 너무 늦게 부른다
- 콜백을 너무 적게 또는 너무 많이 부른다
- 필요한 환경/인자를 정상적으로 콜백에 전달하지 못한다.
- 일어날지 모를 에러/예외를 무시한다.
- ...

이렇듯 너무 많은 실패 하는 경우의 수가 존재한다.

### 남의 코드뿐만 아니라

&nbsp;이런 예기치 못한 상황을 방지하기 위해서 나름의 방어 로직을 짜 넣는다. 콜백에도 계속 손수 필요한 장치를 만들어서 넣어줘야 한다. 그래도 이런 콜백을 넘겨줘도 잘못 틀어질 수 있는 것이 제어의 역전이다.

## 4. 콜백을 구하라

&nbsp;이런 믿음성 문제를 해결하기 위해 기존 디자인을 변경한 콜백 체계가 있다. 분할 콜백(Split Callback)기능을 제공하는 API다.

```javascript
function success(data) {}
function failure(err) {}

// failure는 필수가 아니다
ajax('http://some.url.1', success, failure);
```

에러 우선 스타일(Error first style)이라는 콜백 패턴 또한 많이 사용한다.

```javascript
function response(err, data) {
  if (err) console.log(err);
  else console.log(data);
}

ajax('http://some.url.1', response);
```

하지만 위 두 코드 모두 반복적인 호출을 방지하는 콜백 기능도 없고, 재사용 불가능하며 매번 콜백에 타이핑 해줘야하는 문제가 있다.

콜백을 한 번도 호출하지 않으면 이벤트를 취소하는 타임아웃을 걸어놓아야 한다. 또한 너무 일찍 호출해도 문제다. 이런 비결정성은 버그를 추적하기가 어렵다. 각각의 상황에 대한 해결법은 존재하지만 이런 비대해진 관용 코드가 프로젝트를 짓누를 것이다.

## 5. 정리하기

- 콜백은 JS에서 비동기성을 표현하는 기본 단위다.
- 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내서 추론이 어렵다.
- 그래서 비동기를 동기적, 순차적으로 표현할 방법이 필요하다.
- 콜백은 IoC를 필요로 하기 때문에 여러가지 믿음성 문제에 봉착하게 된다.
- 믿음성을 해결할 수는 있지만 비대해진 관용 코드는 유지 보수를 어렵게 만든다.
